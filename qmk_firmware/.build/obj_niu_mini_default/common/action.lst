   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB13:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "backlight.h"
  24:tmk_core/common/action.c **** #include "action_layer.h"
  25:tmk_core/common/action.c **** #include "action_tapping.h"
  26:tmk_core/common/action.c **** #include "action_macro.h"
  27:tmk_core/common/action.c **** #include "action_util.h"
  28:tmk_core/common/action.c **** #include "action.h"
  29:tmk_core/common/action.c **** #include "wait.h"
  30:tmk_core/common/action.c **** 
  31:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  32:tmk_core/common/action.c **** #include "debug.h"
  33:tmk_core/common/action.c **** #else
  34:tmk_core/common/action.c **** #include "nodebug.h"
  35:tmk_core/common/action.c **** #endif
  36:tmk_core/common/action.c **** 
  37:tmk_core/common/action.c **** int tp_buttons;
  38:tmk_core/common/action.c **** 
  39:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  40:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  41:tmk_core/common/action.c **** #endif
  42:tmk_core/common/action.c **** 
  43:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  44:tmk_core/common/action.c **** #include <fauxclicky.h>
  45:tmk_core/common/action.c **** #endif
  46:tmk_core/common/action.c **** 
  47:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  48:tmk_core/common/action.c **** #  define TAP_CODE_DELAY 0
  49:tmk_core/common/action.c **** #endif
  50:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  51:tmk_core/common/action.c **** #  define TAP_HOLD_CAPS_DELAY 80
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** /** \brief Called to execute an action.
  54:tmk_core/common/action.c ****  *
  55:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  56:tmk_core/common/action.c ****  */
  57:tmk_core/common/action.c **** void action_exec(keyevent_t event)
  58:tmk_core/common/action.c **** {
  16               		.loc 1 58 1 view -0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  59:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  48               		.loc 1 59 5 view .LVU1
  60:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  61:tmk_core/common/action.c ****         dprint("EVENT: "); debug_event(event); dprintln();
  49               		.loc 1 61 58 view .LVU2
  62:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  63:tmk_core/common/action.c ****         retro_tapping_counter++;
  64:tmk_core/common/action.c **** #endif
  65:tmk_core/common/action.c ****     }
  66:tmk_core/common/action.c **** 
  67:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  68:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  69:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  70:tmk_core/common/action.c ****     }
  71:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  72:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  73:tmk_core/common/action.c ****     }
  74:tmk_core/common/action.c ****     fauxclicky_check();
  75:tmk_core/common/action.c **** #endif
  76:tmk_core/common/action.c **** 
  77:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  78:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  79:tmk_core/common/action.c ****         process_hand_swap(&event);
  80:tmk_core/common/action.c ****     }
  81:tmk_core/common/action.c **** #endif
  82:tmk_core/common/action.c **** 
  83:tmk_core/common/action.c ****     keyrecord_t record = { .event = event };
  50               		.loc 1 83 5 view .LVU3
  51               		.loc 1 83 17 is_stmt 0 view .LVU4
  52 001e 1E82      		std Y+6,__zero_reg__
  53 0020 1D82      		std Y+5,__zero_reg__
  54 0022 85E0      		ldi r24,lo8(5)
  55 0024 FE01      		movw r30,r28
  56 0026 3796      		adiw r30,7
  57 0028 DE01      		movw r26,r28
  58 002a 1196      		adiw r26,1
  59               		0:
  60 002c 0190      		ld r0,Z+
  61 002e 0D92      		st X+,r0
  62 0030 8A95      		dec r24
  63 0032 01F4      		brne 0b
  84:tmk_core/common/action.c **** 
  85:tmk_core/common/action.c **** #if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  86:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  87:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  88:tmk_core/common/action.c ****     }
  89:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  90:tmk_core/common/action.c ****         clear_oneshot_mods();
  91:tmk_core/common/action.c ****     }
  92:tmk_core/common/action.c **** #endif
  93:tmk_core/common/action.c **** 
  94:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  95:tmk_core/common/action.c ****     action_tapping_process(record);
  64               		.loc 1 95 5 is_stmt 1 view .LVU5
  65 0034 4981      		ldd r20,Y+1
  66               	.LVL1:
  67               		.loc 1 95 5 is_stmt 0 view .LVU6
  68 0036 5A81      		ldd r21,Y+2
  69               	.LVL2:
  70               		.loc 1 95 5 view .LVU7
  71 0038 6B81      		ldd r22,Y+3
  72 003a 7C81      		ldd r23,Y+4
  73 003c 8D81      		ldd r24,Y+5
  74 003e 9E81      		ldd r25,Y+6
  75               	/* epilogue start */
  96:tmk_core/common/action.c **** #else
  97:tmk_core/common/action.c ****     process_record(&record);
  98:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
  99:tmk_core/common/action.c ****         dprint("processed: "); debug_record(record); dprintln();
 100:tmk_core/common/action.c ****     }
 101:tmk_core/common/action.c **** #endif
 102:tmk_core/common/action.c **** }
  76               		.loc 1 102 1 view .LVU8
  77 0040 2B96      		adiw r28,11
  78 0042 0FB6      		in __tmp_reg__,__SREG__
  79 0044 F894      		cli
  80 0046 DEBF      		out __SP_H__,r29
  81 0048 0FBE      		out __SREG__,__tmp_reg__
  82 004a CDBF      		out __SP_L__,r28
  83 004c DF91      		pop r29
  84 004e CF91      		pop r28
  95:tmk_core/common/action.c **** #else
  85               		.loc 1 95 5 view .LVU9
  86 0050 0C94 0000 		jmp action_tapping_process
  87               	.LVL3:
  88               		.cfi_endproc
  89               	.LFE13:
  91               		.section	.text.process_record_quantum,"ax",@progbits
  92               		.weak	process_record_quantum
  94               	process_record_quantum:
  95               	.LVL4:
  96               	.LFB15:
 103:tmk_core/common/action.c **** 
 104:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 105:tmk_core/common/action.c **** bool swap_hands = false;
 106:tmk_core/common/action.c **** bool swap_held = false;
 107:tmk_core/common/action.c **** 
 108:tmk_core/common/action.c **** /** \brief Process Hand Swap
 109:tmk_core/common/action.c ****  *
 110:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 111:tmk_core/common/action.c ****  */
 112:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 113:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 114:tmk_core/common/action.c **** 
 115:tmk_core/common/action.c ****     keypos_t pos = event->key;
 116:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1<<pos.col;
 117:tmk_core/common/action.c ****     bool do_swap = event->pressed ? swap_hands :
 118:tmk_core/common/action.c ****                                     swap_state[pos.row] & (col_bit);
 119:tmk_core/common/action.c **** 
 120:tmk_core/common/action.c ****     if (do_swap) {
 121:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 122:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 123:tmk_core/common/action.c ****     } else {
 124:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 125:tmk_core/common/action.c ****     }
 126:tmk_core/common/action.c **** }
 127:tmk_core/common/action.c **** #endif
 128:tmk_core/common/action.c **** 
 129:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 130:tmk_core/common/action.c **** bool disable_action_cache = false;
 131:tmk_core/common/action.c **** 
 132:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 133:tmk_core/common/action.c **** {
 134:tmk_core/common/action.c ****     disable_action_cache = true;
 135:tmk_core/common/action.c ****     process_record(record);
 136:tmk_core/common/action.c ****     disable_action_cache = false;
 137:tmk_core/common/action.c **** }
 138:tmk_core/common/action.c **** #else
 139:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 140:tmk_core/common/action.c **** {
 141:tmk_core/common/action.c ****     process_record(record);
 142:tmk_core/common/action.c **** }
 143:tmk_core/common/action.c **** #endif
 144:tmk_core/common/action.c **** 
 145:tmk_core/common/action.c **** __attribute__ ((weak))
 146:tmk_core/common/action.c **** bool process_record_quantum(keyrecord_t *record) {
  97               		.loc 1 146 50 is_stmt 1 view -0
  98               		.cfi_startproc
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
 147:tmk_core/common/action.c ****     return true;
 103               		.loc 1 147 5 view .LVU11
 148:tmk_core/common/action.c **** }
 104               		.loc 1 148 1 is_stmt 0 view .LVU12
 105 0000 81E0      		ldi r24,lo8(1)
 106               	.LVL5:
 107               	/* epilogue start */
 108               		.loc 1 148 1 view .LVU13
 109 0002 0895      		ret
 110               		.cfi_endproc
 111               	.LFE15:
 113               		.section	.text.process_record_tap_hint,"ax",@progbits
 114               	.global	process_record_tap_hint
 116               	process_record_tap_hint:
 117               	.LVL6:
 118               	.LFB16:
 149:tmk_core/common/action.c **** 
 150:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 151:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 152:tmk_core/common/action.c ****  *
 153:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 154:tmk_core/common/action.c ****  */
 155:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record)
 156:tmk_core/common/action.c **** {
 119               		.loc 1 156 1 is_stmt 1 view -0
 120               		.cfi_startproc
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               	/* stack size = 0 */
 124               	.L__stack_usage = 0
 157:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 125               		.loc 1 157 5 view .LVU15
 126               		.loc 1 157 23 is_stmt 0 view .LVU16
 127 0000 FC01      		movw r30,r24
 128 0002 8081      		ld r24,Z
 129 0004 9181      		ldd r25,Z+1
 130               	.LVL7:
 131               		.loc 1 157 23 view .LVU17
 132 0006 0C94 0000 		jmp layer_switch_get_action
 133               	.LVL8:
 134               		.loc 1 157 23 view .LVU18
 135               		.cfi_endproc
 136               	.LFE16:
 138               		.section	.text.register_code,"ax",@progbits
 139               	.global	register_code
 141               	register_code:
 142               	.LVL9:
 143               	.LFB19:
 158:tmk_core/common/action.c **** 
 159:tmk_core/common/action.c ****     switch (action.kind.id) {
 160:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 161:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 162:tmk_core/common/action.c ****             switch (action.swap.code) {
 163:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 164:tmk_core/common/action.c ****                 default:
 165:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 166:tmk_core/common/action.c ****                     swap_held = true;
 167:tmk_core/common/action.c ****             }
 168:tmk_core/common/action.c ****             break;
 169:tmk_core/common/action.c **** #endif
 170:tmk_core/common/action.c ****     }
 171:tmk_core/common/action.c **** }
 172:tmk_core/common/action.c **** #endif
 173:tmk_core/common/action.c **** 
 174:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 175:tmk_core/common/action.c ****  *
 176:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 177:tmk_core/common/action.c ****  */
 178:tmk_core/common/action.c **** void process_record(keyrecord_t *record)
 179:tmk_core/common/action.c **** {
 180:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 181:tmk_core/common/action.c **** 
 182:tmk_core/common/action.c ****     if(!process_record_quantum(record))
 183:tmk_core/common/action.c ****         return;
 184:tmk_core/common/action.c **** 
 185:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 186:tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 187:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 188:tmk_core/common/action.c ****     dprint(" layer_state: "); layer_debug();
 189:tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 190:tmk_core/common/action.c **** #endif
 191:tmk_core/common/action.c ****     dprintln();
 192:tmk_core/common/action.c **** 
 193:tmk_core/common/action.c ****     process_action(record, action);
 194:tmk_core/common/action.c **** }
 195:tmk_core/common/action.c **** 
 196:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 197:tmk_core/common/action.c ****  *
 198:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 199:tmk_core/common/action.c ****  */
 200:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action)
 201:tmk_core/common/action.c **** {
 202:tmk_core/common/action.c ****     keyevent_t event = record->event;
 203:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 204:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 205:tmk_core/common/action.c **** #endif
 206:tmk_core/common/action.c **** 
 207:tmk_core/common/action.c ****     if (event.pressed) {
 208:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 209:tmk_core/common/action.c ****         clear_weak_mods();
 210:tmk_core/common/action.c ****     }
 211:tmk_core/common/action.c **** 
 212:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 213:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 214:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 215:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 216:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 217:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 218:tmk_core/common/action.c ****     }
 219:tmk_core/common/action.c **** #endif
 220:tmk_core/common/action.c **** 
 221:tmk_core/common/action.c ****     switch (action.kind.id) {
 222:tmk_core/common/action.c ****         /* Key and Mods */
 223:tmk_core/common/action.c ****         case ACT_LMODS:
 224:tmk_core/common/action.c ****         case ACT_RMODS:
 225:tmk_core/common/action.c ****             {
 226:tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS) ?  action.key.mods :
 227:tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 228:tmk_core/common/action.c ****                 if (event.pressed) {
 229:tmk_core/common/action.c ****                     if (mods) {
 230:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 231:tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 232:tmk_core/common/action.c ****                             // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSF
 233:tmk_core/common/action.c ****                             // Same applies for some keys like KC_MEH which are declared as MEH(KC_
 234:tmk_core/common/action.c ****                             add_mods(mods);
 235:tmk_core/common/action.c ****                         } else {
 236:tmk_core/common/action.c ****                             add_weak_mods(mods);
 237:tmk_core/common/action.c ****                         }
 238:tmk_core/common/action.c ****                         send_keyboard_report();
 239:tmk_core/common/action.c ****                     }
 240:tmk_core/common/action.c ****                     register_code(action.key.code);
 241:tmk_core/common/action.c ****                 } else {
 242:tmk_core/common/action.c ****                     unregister_code(action.key.code);
 243:tmk_core/common/action.c ****                     if (mods) {
 244:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 245:tmk_core/common/action.c ****                             del_mods(mods);
 246:tmk_core/common/action.c ****                         } else {
 247:tmk_core/common/action.c ****                             del_weak_mods(mods);
 248:tmk_core/common/action.c ****                         }
 249:tmk_core/common/action.c ****                         send_keyboard_report();
 250:tmk_core/common/action.c ****                     }
 251:tmk_core/common/action.c ****                 }
 252:tmk_core/common/action.c ****             }
 253:tmk_core/common/action.c ****             break;
 254:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 255:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 256:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 257:tmk_core/common/action.c ****             {
 258:tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ?  action.key.mods :
 259:tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 260:tmk_core/common/action.c ****                 switch (action.layer_tap.code) {
 261:tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 262:tmk_core/common/action.c ****                     case MODS_ONESHOT:
 263:tmk_core/common/action.c ****                         // Oneshot modifier
 264:tmk_core/common/action.c ****                         if (event.pressed) {
 265:tmk_core/common/action.c ****                             if (tap_count == 0) {
 266:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 267:tmk_core/common/action.c ****                                 register_mods(mods | get_oneshot_mods());
 268:tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 269:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 270:tmk_core/common/action.c ****                                 set_oneshot_mods(mods | get_oneshot_mods());
 271:tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 272:tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 273:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Toggling oneshot");
 274:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 275:tmk_core/common/action.c ****                                 set_oneshot_locked_mods(mods);
 276:tmk_core/common/action.c ****                                 register_mods(mods);
 277:tmk_core/common/action.c ****                     #endif
 278:tmk_core/common/action.c ****                             } else {
 279:tmk_core/common/action.c ****                                 register_mods(mods | get_oneshot_mods());
 280:tmk_core/common/action.c ****                             }
 281:tmk_core/common/action.c ****                         } else {
 282:tmk_core/common/action.c ****                             if (tap_count == 0) {
 283:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 284:tmk_core/common/action.c ****                                 unregister_mods(mods);
 285:tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 286:tmk_core/common/action.c ****                                 // Retain Oneshot mods
 287:tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 288:tmk_core/common/action.c ****                                 if (mods & get_mods()) {
 289:tmk_core/common/action.c ****                                     clear_oneshot_locked_mods();
 290:tmk_core/common/action.c ****                                     clear_oneshot_mods();
 291:tmk_core/common/action.c ****                                     unregister_mods(mods);
 292:tmk_core/common/action.c ****                                 }
 293:tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 294:tmk_core/common/action.c ****                                 // Toggle Oneshot Layer
 295:tmk_core/common/action.c ****                     #endif
 296:tmk_core/common/action.c ****                             } else {
 297:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 298:tmk_core/common/action.c ****                                 unregister_mods(mods);
 299:tmk_core/common/action.c ****                             }
 300:tmk_core/common/action.c ****                         }
 301:tmk_core/common/action.c ****                         break;
 302:tmk_core/common/action.c ****     #endif
 303:tmk_core/common/action.c ****                     case MODS_TAP_TOGGLE:
 304:tmk_core/common/action.c ****                         if (event.pressed) {
 305:tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 306:tmk_core/common/action.c ****                                 register_mods(mods);
 307:tmk_core/common/action.c ****                             }
 308:tmk_core/common/action.c ****                         } else {
 309:tmk_core/common/action.c ****                             if (tap_count < TAPPING_TOGGLE) {
 310:tmk_core/common/action.c ****                                 unregister_mods(mods);
 311:tmk_core/common/action.c ****                             }
 312:tmk_core/common/action.c ****                         }
 313:tmk_core/common/action.c ****                         break;
 314:tmk_core/common/action.c ****                     default:
 315:tmk_core/common/action.c ****                         if (event.pressed) {
 316:tmk_core/common/action.c ****                             if (tap_count > 0) {
 317:tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 318:tmk_core/common/action.c ****                                 if (record->tap.interrupted) {
 319:tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 320:tmk_core/common/action.c ****                                     // ad hoc: set 0 to cancel tap
 321:tmk_core/common/action.c ****                                     record->tap.count = 0;
 322:tmk_core/common/action.c ****                                     register_mods(mods);
 323:tmk_core/common/action.c ****                                 } else
 324:tmk_core/common/action.c **** #endif
 325:tmk_core/common/action.c ****                                 {
 326:tmk_core/common/action.c ****                                     dprint("MODS_TAP: Tap: register_code\n");
 327:tmk_core/common/action.c ****                                     register_code(action.key.code);
 328:tmk_core/common/action.c ****                                 }
 329:tmk_core/common/action.c ****                             } else {
 330:tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 331:tmk_core/common/action.c ****                                 register_mods(mods);
 332:tmk_core/common/action.c ****                             }
 333:tmk_core/common/action.c ****                         } else {
 334:tmk_core/common/action.c ****                             if (tap_count > 0) {
 335:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 336:tmk_core/common/action.c ****                                 if (action.layer_tap.code == KC_CAPS) {
 337:tmk_core/common/action.c ****                                   wait_ms(TAP_HOLD_CAPS_DELAY);
 338:tmk_core/common/action.c ****                                 }
 339:tmk_core/common/action.c ****                                 unregister_code(action.key.code);
 340:tmk_core/common/action.c ****                             } else {
 341:tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 342:tmk_core/common/action.c ****                                 unregister_mods(mods);
 343:tmk_core/common/action.c ****                             }
 344:tmk_core/common/action.c ****                         }
 345:tmk_core/common/action.c ****                         break;
 346:tmk_core/common/action.c ****                 }
 347:tmk_core/common/action.c ****             }
 348:tmk_core/common/action.c ****             break;
 349:tmk_core/common/action.c **** #endif
 350:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 351:tmk_core/common/action.c ****         /* other HID usage */
 352:tmk_core/common/action.c ****         case ACT_USAGE:
 353:tmk_core/common/action.c ****             switch (action.usage.page) {
 354:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 355:tmk_core/common/action.c ****                     if (event.pressed) {
 356:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 357:tmk_core/common/action.c ****                     } else {
 358:tmk_core/common/action.c ****                         host_system_send(0);
 359:tmk_core/common/action.c ****                     }
 360:tmk_core/common/action.c ****                     break;
 361:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 362:tmk_core/common/action.c ****                     if (event.pressed) {
 363:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 364:tmk_core/common/action.c ****                     } else {
 365:tmk_core/common/action.c ****                         host_consumer_send(0);
 366:tmk_core/common/action.c ****                     }
 367:tmk_core/common/action.c ****                     break;
 368:tmk_core/common/action.c ****             }
 369:tmk_core/common/action.c ****             break;
 370:tmk_core/common/action.c **** #endif
 371:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 372:tmk_core/common/action.c ****         /* Mouse key */
 373:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 374:tmk_core/common/action.c ****             if (event.pressed) {
 375:tmk_core/common/action.c ****                 switch (action.key.code) {
 376:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 377:tmk_core/common/action.c ****                         tp_buttons |= (1<<0);
 378:tmk_core/common/action.c ****                         break;
 379:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 380:tmk_core/common/action.c ****                         tp_buttons |= (1<<1);
 381:tmk_core/common/action.c ****                         break;
 382:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 383:tmk_core/common/action.c ****                         tp_buttons |= (1<<2);
 384:tmk_core/common/action.c ****                         break;
 385:tmk_core/common/action.c ****                     default:
 386:tmk_core/common/action.c ****                         break;
 387:tmk_core/common/action.c ****                 }
 388:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 389:tmk_core/common/action.c ****                 mousekey_send();
 390:tmk_core/common/action.c ****             } else {
 391:tmk_core/common/action.c ****                 switch (action.key.code) {
 392:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 393:tmk_core/common/action.c ****                         tp_buttons &= ~(1<<0);
 394:tmk_core/common/action.c ****                         break;
 395:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 396:tmk_core/common/action.c ****                         tp_buttons &= ~(1<<1);
 397:tmk_core/common/action.c ****                         break;
 398:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 399:tmk_core/common/action.c ****                         tp_buttons &= ~(1<<2);
 400:tmk_core/common/action.c ****                         break;
 401:tmk_core/common/action.c ****                     default:
 402:tmk_core/common/action.c ****                         break;
 403:tmk_core/common/action.c ****                 }
 404:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 405:tmk_core/common/action.c ****                 mousekey_send();
 406:tmk_core/common/action.c ****             }
 407:tmk_core/common/action.c ****             break;
 408:tmk_core/common/action.c **** #endif
 409:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 410:tmk_core/common/action.c ****         case ACT_LAYER:
 411:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 412:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 413:tmk_core/common/action.c ****                 if (!event.pressed) {
 414:tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 415:tmk_core/common/action.c ****                     layer_state_t bits = ((layer_state_t)action.layer_bitop.bits)<<shift;
 416:tmk_core/common/action.c ****                     layer_state_t mask = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf)<<shift)
 417:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 418:tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 419:tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 420:tmk_core/common/action.c ****                         case OP_BIT_XOR: default_layer_xor(bits | mask); break;
 421:tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_set(bits | mask); break;
 422:tmk_core/common/action.c ****                     }
 423:tmk_core/common/action.c ****                 }
 424:tmk_core/common/action.c ****             } else {
 425:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 426:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 427:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 428:tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 429:tmk_core/common/action.c ****                     layer_state_t bits = ((layer_state_t)action.layer_bitop.bits)<<shift;
 430:tmk_core/common/action.c ****                     layer_state_t mask = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf)<<shift)
 431:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 432:tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 433:tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 434:tmk_core/common/action.c ****                         case OP_BIT_XOR: layer_xor(bits | mask); break;
 435:tmk_core/common/action.c ****                         case OP_BIT_SET: layer_state_set(bits | mask); break;
 436:tmk_core/common/action.c ****                     }
 437:tmk_core/common/action.c ****                 }
 438:tmk_core/common/action.c ****             }
 439:tmk_core/common/action.c ****             break;
 440:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 441:tmk_core/common/action.c ****             if (event.pressed) {
 442:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 443:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 444:tmk_core/common/action.c ****             } else {
 445:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 446:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 447:tmk_core/common/action.c ****             }
 448:tmk_core/common/action.c ****             break;
 449:tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 450:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 451:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 452:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 453:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 454:tmk_core/common/action.c ****                     /* tap toggle */
 455:tmk_core/common/action.c ****                     if (event.pressed) {
 456:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 457:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 458:tmk_core/common/action.c ****                         }
 459:tmk_core/common/action.c ****                     } else {
 460:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 461:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 462:tmk_core/common/action.c ****                         }
 463:tmk_core/common/action.c ****                     }
 464:tmk_core/common/action.c ****                     break;
 465:tmk_core/common/action.c ****                 case OP_ON_OFF:
 466:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) :
 467:tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 468:tmk_core/common/action.c ****                     break;
 469:tmk_core/common/action.c ****                 case OP_OFF_ON:
 470:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) :
 471:tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 472:tmk_core/common/action.c ****                     break;
 473:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 474:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) :
 475:tmk_core/common/action.c ****                                     layer_clear();
 476:tmk_core/common/action.c ****                     break;
 477:tmk_core/common/action.c ****             #ifndef NO_ACTION_ONESHOT
 478:tmk_core/common/action.c ****                 case OP_ONESHOT:
 479:tmk_core/common/action.c ****                     // Oneshot modifier
 480:tmk_core/common/action.c ****                 #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 481:tmk_core/common/action.c ****                     do_release_oneshot = false;
 482:tmk_core/common/action.c ****                     if (event.pressed) {
 483:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 484:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 485:tmk_core/common/action.c ****                             reset_oneshot_layer();
 486:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 487:tmk_core/common/action.c ****                             break;
 488:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 489:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 490:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 491:tmk_core/common/action.c ****                         }
 492:tmk_core/common/action.c ****                     } else {
 493:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 494:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 495:tmk_core/common/action.c ****                             reset_oneshot_layer();
 496:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 497:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 498:tmk_core/common/action.c ****                         } else {
 499:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 500:tmk_core/common/action.c ****                         }
 501:tmk_core/common/action.c ****                     }
 502:tmk_core/common/action.c ****                 #else
 503:tmk_core/common/action.c ****                     if (event.pressed) {
 504:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 505:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 506:tmk_core/common/action.c ****                     } else {
 507:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 508:tmk_core/common/action.c ****                         if (tap_count > 1) {
 509:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 510:tmk_core/common/action.c ****                         }
 511:tmk_core/common/action.c ****                     }
 512:tmk_core/common/action.c ****                 #endif
 513:tmk_core/common/action.c ****                     break;
 514:tmk_core/common/action.c ****             #endif
 515:tmk_core/common/action.c ****                 default:
 516:tmk_core/common/action.c ****                     /* tap key */
 517:tmk_core/common/action.c ****                     if (event.pressed) {
 518:tmk_core/common/action.c ****                         if (tap_count > 0) {
 519:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 520:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 521:tmk_core/common/action.c ****                         } else {
 522:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 523:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 524:tmk_core/common/action.c ****                         }
 525:tmk_core/common/action.c ****                     } else {
 526:tmk_core/common/action.c ****                         if (tap_count > 0) {
 527:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 528:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 529:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 530:tmk_core/common/action.c ****                             } else {
 531:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 532:tmk_core/common/action.c ****                               }
 533:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 534:tmk_core/common/action.c ****                         } else {
 535:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 536:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 537:tmk_core/common/action.c ****                         }
 538:tmk_core/common/action.c ****                     }
 539:tmk_core/common/action.c ****                     break;
 540:tmk_core/common/action.c ****             }
 541:tmk_core/common/action.c ****             break;
 542:tmk_core/common/action.c ****     #endif
 543:tmk_core/common/action.c **** #endif
 544:tmk_core/common/action.c ****         /* Extentions */
 545:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 546:tmk_core/common/action.c ****         case ACT_MACRO:
 547:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 548:tmk_core/common/action.c ****             break;
 549:tmk_core/common/action.c **** #endif
 550:tmk_core/common/action.c **** #if defined(BACKLIGHT_ENABLE) | defined(LED_MATRIX_ENABLE)
 551:tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 552:tmk_core/common/action.c ****             if (!event.pressed) {
 553:tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 554:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 555:tmk_core/common/action.c ****                         backlight_increase();
 556:tmk_core/common/action.c ****                         break;
 557:tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 558:tmk_core/common/action.c ****                         backlight_decrease();
 559:tmk_core/common/action.c ****                         break;
 560:tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 561:tmk_core/common/action.c ****                         backlight_toggle();
 562:tmk_core/common/action.c ****                         break;
 563:tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 564:tmk_core/common/action.c ****                         backlight_step();
 565:tmk_core/common/action.c ****                         break;
 566:tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 567:tmk_core/common/action.c ****                         backlight_level(BACKLIGHT_LEVELS);
 568:tmk_core/common/action.c ****                         break;
 569:tmk_core/common/action.c ****                     case BACKLIGHT_OFF:
 570:tmk_core/common/action.c ****                         backlight_level(0);
 571:tmk_core/common/action.c ****                         break;
 572:tmk_core/common/action.c ****                 }
 573:tmk_core/common/action.c ****             }
 574:tmk_core/common/action.c ****             break;
 575:tmk_core/common/action.c **** #endif
 576:tmk_core/common/action.c ****         case ACT_COMMAND:
 577:tmk_core/common/action.c ****             break;
 578:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 579:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 580:tmk_core/common/action.c ****             switch (action.swap.code) {
 581:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 582:tmk_core/common/action.c ****                     if (event.pressed) {
 583:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 584:tmk_core/common/action.c ****                     }
 585:tmk_core/common/action.c ****                     break;
 586:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 587:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 588:tmk_core/common/action.c ****                     break;
 589:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 590:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 591:tmk_core/common/action.c ****                     break;
 592:tmk_core/common/action.c ****                 case OP_SH_ON:
 593:tmk_core/common/action.c ****                     if (!event.pressed) {
 594:tmk_core/common/action.c ****                         swap_hands = true;
 595:tmk_core/common/action.c ****                     }
 596:tmk_core/common/action.c ****                     break;
 597:tmk_core/common/action.c ****                 case OP_SH_OFF:
 598:tmk_core/common/action.c ****                     if (!event.pressed) {
 599:tmk_core/common/action.c ****                         swap_hands = false;
 600:tmk_core/common/action.c ****                     }
 601:tmk_core/common/action.c ****                     break;
 602:tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 603:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 604:tmk_core/common/action.c ****                     /* tap toggle */
 605:tmk_core/common/action.c **** 
 606:tmk_core/common/action.c ****                     if (event.pressed) {
 607:tmk_core/common/action.c ****                         if (swap_held) {
 608:tmk_core/common/action.c ****                             swap_held = false;
 609:tmk_core/common/action.c ****                         } else {
 610:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 611:tmk_core/common/action.c ****                         }
 612:tmk_core/common/action.c ****                     } else {
 613:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 614:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 615:tmk_core/common/action.c ****                         }
 616:tmk_core/common/action.c ****                     }
 617:tmk_core/common/action.c ****                     break;
 618:tmk_core/common/action.c ****                 default:
 619:tmk_core/common/action.c ****                     /* tap key */
 620:tmk_core/common/action.c ****                     if (tap_count > 0) {
 621:tmk_core/common/action.c ****                         if (swap_held) {
 622:tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 623:tmk_core/common/action.c ****                             swap_held = false;
 624:tmk_core/common/action.c ****                         }
 625:tmk_core/common/action.c ****                         if (event.pressed) {
 626:tmk_core/common/action.c ****                             register_code(action.swap.code);
 627:tmk_core/common/action.c ****                         } else {
 628:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 629:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 630:tmk_core/common/action.c ****                             *record = (keyrecord_t){}; // hack: reset tap mode
 631:tmk_core/common/action.c ****                         }
 632:tmk_core/common/action.c ****                     } else {
 633:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 634:tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 635:tmk_core/common/action.c ****                             swap_held = false;
 636:tmk_core/common/action.c ****                         }
 637:tmk_core/common/action.c ****                     }
 638:tmk_core/common/action.c ****     #endif
 639:tmk_core/common/action.c ****             }
 640:tmk_core/common/action.c **** #endif
 641:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 642:tmk_core/common/action.c ****         case ACT_FUNCTION:
 643:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 644:tmk_core/common/action.c ****             break;
 645:tmk_core/common/action.c **** #endif
 646:tmk_core/common/action.c ****         default:
 647:tmk_core/common/action.c ****             break;
 648:tmk_core/common/action.c ****     }
 649:tmk_core/common/action.c **** 
 650:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 651:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 652:tmk_core/common/action.c ****     switch (action.kind.id) {
 653:tmk_core/common/action.c ****         case ACT_LAYER:
 654:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 655:tmk_core/common/action.c ****         #ifndef NO_ACTION_TAPPING
 656:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 657:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 658:tmk_core/common/action.c ****         #endif
 659:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 660:tmk_core/common/action.c ****             break;
 661:tmk_core/common/action.c ****         default:
 662:tmk_core/common/action.c ****             break;
 663:tmk_core/common/action.c ****     }
 664:tmk_core/common/action.c **** #endif
 665:tmk_core/common/action.c **** 
 666:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 667:tmk_core/common/action.c ****   #ifdef RETRO_TAPPING
 668:tmk_core/common/action.c ****   if (!is_tap_action(action)) {
 669:tmk_core/common/action.c ****     retro_tapping_counter = 0;
 670:tmk_core/common/action.c ****   } else {
 671:tmk_core/common/action.c ****     if (event.pressed) {
 672:tmk_core/common/action.c ****         if (tap_count > 0) {
 673:tmk_core/common/action.c ****           retro_tapping_counter = 0;
 674:tmk_core/common/action.c ****         } else {
 675:tmk_core/common/action.c **** 
 676:tmk_core/common/action.c ****         }
 677:tmk_core/common/action.c ****     } else {
 678:tmk_core/common/action.c ****       if (tap_count > 0) {
 679:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 680:tmk_core/common/action.c ****       } else {
 681:tmk_core/common/action.c ****         if (retro_tapping_counter == 2) {
 682:tmk_core/common/action.c ****           tap_code(action.layer_tap.code);
 683:tmk_core/common/action.c ****         }
 684:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 685:tmk_core/common/action.c ****       }
 686:tmk_core/common/action.c ****     }
 687:tmk_core/common/action.c ****   }
 688:tmk_core/common/action.c ****   #endif
 689:tmk_core/common/action.c **** #endif
 690:tmk_core/common/action.c **** 
 691:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 692:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 693:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 694:tmk_core/common/action.c ****      */
 695:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED )   ) {
 696:tmk_core/common/action.c ****         record->event.pressed = false;
 697:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 698:tmk_core/common/action.c ****         process_record(record);
 699:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 700:tmk_core/common/action.c ****     }
 701:tmk_core/common/action.c **** #endif
 702:tmk_core/common/action.c **** }
 703:tmk_core/common/action.c **** 
 704:tmk_core/common/action.c **** 
 705:tmk_core/common/action.c **** 
 706:tmk_core/common/action.c **** 
 707:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 708:tmk_core/common/action.c ****  *
 709:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 710:tmk_core/common/action.c ****  */
 711:tmk_core/common/action.c **** void register_code(uint8_t code)
 712:tmk_core/common/action.c **** {
 144               		.loc 1 712 1 is_stmt 1 view -0
 145               		.cfi_startproc
 146               	/* prologue: function */
 147               	/* frame size = 0 */
 148               	/* stack size = 0 */
 149               	.L__stack_usage = 0
 713:tmk_core/common/action.c ****     if (code == KC_NO) {
 150               		.loc 1 713 5 view .LVU20
 151               		.loc 1 713 8 is_stmt 0 view .LVU21
 152 0000 8823      		tst r24
 153 0002 01F4      		brne .+2
 154 0004 00C0      		rjmp .L4
 714:tmk_core/common/action.c ****         return;
 715:tmk_core/common/action.c ****     }
 716:tmk_core/common/action.c **** 
 717:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 718:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 155               		.loc 1 718 10 is_stmt 1 view .LVU22
 156               		.loc 1 718 13 is_stmt 0 view .LVU23
 157 0006 8238      		cpi r24,lo8(-126)
 158 0008 01F4      		brne .L7
 719:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 720:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 721:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK)) return;
 159               		.loc 1 721 9 is_stmt 1 view .LVU24
 160               		.loc 1 721 13 is_stmt 0 view .LVU25
 161 000a 0E94 0000 		call host_keyboard_leds
 162               	.LVL10:
 163               		.loc 1 721 12 view .LVU26
 164 000e 81FD      		sbrc r24,1
 165 0010 00C0      		rjmp .L4
 722:tmk_core/common/action.c **** #endif
 723:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 166               		.loc 1 723 9 is_stmt 1 view .LVU27
 167 0012 89E3      		ldi r24,lo8(57)
 168 0014 0E94 0000 		call add_key
 169               	.LVL11:
 724:tmk_core/common/action.c ****         send_keyboard_report();
 170               		.loc 1 724 9 view .LVU28
 171 0018 0E94 0000 		call send_keyboard_report
 172               	.LVL12:
 725:tmk_core/common/action.c ****         wait_ms(100);
 173               		.loc 1 725 9 view .LVU29
 174               	.LBB22:
 175               	.LBI22:
 176               		.file 2 "/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 177               		.loc 2 166 1 view .LVU30
 178               	.LBB23:
 167:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	double __tmp ;
 179               		.loc 2 168 2 view .LVU31
 169:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 180               		.loc 2 172 2 view .LVU32
 173:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 181               		.loc 2 173 2 view .LVU33
 174:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 182               		.loc 2 174 2 view .LVU34
 175:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 183               		.loc 2 184 3 view .LVU35
 185:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 184               		.loc 2 187 2 view .LVU36
 185 001c 2FEF      		ldi r18,lo8(319999)
 186 001e 81EE      		ldi r24,hi8(319999)
 187 0020 94E0      		ldi r25,hlo8(319999)
 188 0022 2150      	1:	subi r18,1
 189 0024 8040      		sbci r24,0
 190 0026 9040      		sbci r25,0
 191 0028 01F4      		brne 1b
 192 002a 00C0      		rjmp .
 193 002c 0000      		nop
 194               	.LVL13:
 195               		.loc 2 187 2 is_stmt 0 view .LVU37
 196               	.LBE23:
 197               	.LBE22:
 726:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 198               		.loc 1 726 9 is_stmt 1 view .LVU38
 199 002e 89E3      		ldi r24,lo8(57)
 200               	.L41:
 727:tmk_core/common/action.c ****         send_keyboard_report();
 728:tmk_core/common/action.c ****     }
 729:tmk_core/common/action.c **** 
 730:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 731:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 732:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_NUM_LOCK)) return;
 733:tmk_core/common/action.c **** #endif
 734:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 735:tmk_core/common/action.c ****         send_keyboard_report();
 736:tmk_core/common/action.c ****         wait_ms(100);
 737:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 201               		.loc 1 737 9 is_stmt 0 view .LVU39
 202 0030 0E94 0000 		call del_key
 203               	.LVL14:
 204               	.L42:
 738:tmk_core/common/action.c ****         send_keyboard_report();
 205               		.loc 1 738 9 is_stmt 1 view .LVU40
 206 0034 0C94 0000 		jmp send_keyboard_report
 207               	.LVL15:
 208               	.L7:
 730:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 209               		.loc 1 730 10 view .LVU41
 730:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 210               		.loc 1 730 13 is_stmt 0 view .LVU42
 211 0038 8338      		cpi r24,lo8(-125)
 212 003a 01F4      		brne .L9
 732:tmk_core/common/action.c **** #endif
 213               		.loc 1 732 9 is_stmt 1 view .LVU43
 732:tmk_core/common/action.c **** #endif
 214               		.loc 1 732 13 is_stmt 0 view .LVU44
 215 003c 0E94 0000 		call host_keyboard_leds
 216               	.LVL16:
 732:tmk_core/common/action.c **** #endif
 217               		.loc 1 732 12 view .LVU45
 218 0040 80FD      		sbrc r24,0
 219 0042 00C0      		rjmp .L4
 734:tmk_core/common/action.c ****         send_keyboard_report();
 220               		.loc 1 734 9 is_stmt 1 view .LVU46
 221 0044 83E5      		ldi r24,lo8(83)
 222 0046 0E94 0000 		call add_key
 223               	.LVL17:
 735:tmk_core/common/action.c ****         wait_ms(100);
 224               		.loc 1 735 9 view .LVU47
 225 004a 0E94 0000 		call send_keyboard_report
 226               	.LVL18:
 736:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 227               		.loc 1 736 9 view .LVU48
 228               	.LBB24:
 229               	.LBI24:
 166:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** {
 230               		.loc 2 166 1 view .LVU49
 231               	.LBB25:
 168:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 232               		.loc 2 168 2 view .LVU50
 172:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233               		.loc 2 172 2 view .LVU51
 173:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 234               		.loc 2 173 2 view .LVU52
 174:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 235               		.loc 2 174 2 view .LVU53
 184:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	#endif
 236               		.loc 2 184 3 view .LVU54
 237               		.loc 2 187 2 view .LVU55
 238 004e 2FEF      		ldi r18,lo8(319999)
 239 0050 81EE      		ldi r24,hi8(319999)
 240 0052 94E0      		ldi r25,hlo8(319999)
 241 0054 2150      	1:	subi r18,1
 242 0056 8040      		sbci r24,0
 243 0058 9040      		sbci r25,0
 244 005a 01F4      		brne 1b
 245 005c 00C0      		rjmp .
 246 005e 0000      		nop
 247               	.LVL19:
 248               		.loc 2 187 2 is_stmt 0 view .LVU56
 249               	.LBE25:
 250               	.LBE24:
 737:tmk_core/common/action.c ****         send_keyboard_report();
 251               		.loc 1 737 9 is_stmt 1 view .LVU57
 252 0060 83E5      		ldi r24,lo8(83)
 253 0062 00C0      		rjmp .L41
 254               	.LVL20:
 255               	.L9:
 739:tmk_core/common/action.c ****     }
 740:tmk_core/common/action.c **** 
 741:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 256               		.loc 1 741 10 view .LVU58
 257               		.loc 1 741 13 is_stmt 0 view .LVU59
 258 0064 8438      		cpi r24,lo8(-124)
 259 0066 01F4      		brne .L10
 742:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 743:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK)) return;
 260               		.loc 1 743 9 is_stmt 1 view .LVU60
 261               		.loc 1 743 13 is_stmt 0 view .LVU61
 262 0068 0E94 0000 		call host_keyboard_leds
 263               	.LVL21:
 264               		.loc 1 743 12 view .LVU62
 265 006c 82FD      		sbrc r24,2
 266 006e 00C0      		rjmp .L4
 744:tmk_core/common/action.c **** #endif
 745:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 267               		.loc 1 745 9 is_stmt 1 view .LVU63
 268 0070 87E4      		ldi r24,lo8(71)
 269 0072 0E94 0000 		call add_key
 270               	.LVL22:
 746:tmk_core/common/action.c ****         send_keyboard_report();
 271               		.loc 1 746 9 view .LVU64
 272 0076 0E94 0000 		call send_keyboard_report
 273               	.LVL23:
 747:tmk_core/common/action.c ****         wait_ms(100);
 274               		.loc 1 747 9 view .LVU65
 275               	.LBB26:
 276               	.LBI26:
 166:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** {
 277               		.loc 2 166 1 view .LVU66
 278               	.LBB27:
 168:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 279               		.loc 2 168 2 view .LVU67
 172:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 280               		.loc 2 172 2 view .LVU68
 173:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 281               		.loc 2 173 2 view .LVU69
 174:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 282               		.loc 2 174 2 view .LVU70
 184:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	#endif
 283               		.loc 2 184 3 view .LVU71
 284               		.loc 2 187 2 view .LVU72
 285 007a 2FEF      		ldi r18,lo8(319999)
 286 007c 81EE      		ldi r24,hi8(319999)
 287 007e 94E0      		ldi r25,hlo8(319999)
 288 0080 2150      	1:	subi r18,1
 289 0082 8040      		sbci r24,0
 290 0084 9040      		sbci r25,0
 291 0086 01F4      		brne 1b
 292 0088 00C0      		rjmp .
 293 008a 0000      		nop
 294               	.LVL24:
 295               		.loc 2 187 2 is_stmt 0 view .LVU73
 296               	.LBE27:
 297               	.LBE26:
 748:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 298               		.loc 1 748 9 is_stmt 1 view .LVU74
 299 008c 87E4      		ldi r24,lo8(71)
 300 008e 00C0      		rjmp .L41
 301               	.LVL25:
 302               	.L10:
 749:tmk_core/common/action.c ****         send_keyboard_report();
 750:tmk_core/common/action.c ****     }
 751:tmk_core/common/action.c **** #endif
 752:tmk_core/common/action.c **** 
 753:tmk_core/common/action.c ****     else if IS_KEY(code) {
 303               		.loc 1 753 10 view .LVU75
 304               		.loc 1 753 13 is_stmt 0 view .LVU76
 305 0090 9CEF      		ldi r25,lo8(-4)
 306 0092 980F      		add r25,r24
 307 0094 913A      		cpi r25,lo8(-95)
 308 0096 00F4      		brsh .L11
 754:tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 755:tmk_core/common/action.c ****         if (command_proc(code)) return;
 309               		.loc 1 755 9 is_stmt 1 view .LVU77
 756:tmk_core/common/action.c **** 
 757:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 758:tmk_core/common/action.c **** /* TODO: remove
 759:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 760:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 761:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 762:tmk_core/common/action.c **** 
 763:tmk_core/common/action.c ****             add_key(code);
 764:tmk_core/common/action.c ****             send_keyboard_report();
 765:tmk_core/common/action.c **** 
 766:tmk_core/common/action.c ****             set_mods(tmp_mods);
 767:tmk_core/common/action.c ****             send_keyboard_report();
 768:tmk_core/common/action.c ****             oneshot_cancel();
 769:tmk_core/common/action.c ****         } else
 770:tmk_core/common/action.c **** */
 771:tmk_core/common/action.c **** #endif
 772:tmk_core/common/action.c ****         {
 773:tmk_core/common/action.c ****             add_key(code);
 310               		.loc 1 773 13 view .LVU78
 311 0098 0E94 0000 		call add_key
 312               	.LVL26:
 774:tmk_core/common/action.c ****             send_keyboard_report();
 313               		.loc 1 774 13 view .LVU79
 314 009c 00C0      		rjmp .L42
 315               	.LVL27:
 316               	.L11:
 775:tmk_core/common/action.c ****         }
 776:tmk_core/common/action.c ****     }
 777:tmk_core/common/action.c ****     else if IS_MOD(code) {
 317               		.loc 1 777 10 view .LVU80
 318               		.loc 1 777 13 is_stmt 0 view .LVU81
 319 009e 90E2      		ldi r25,lo8(32)
 320 00a0 980F      		add r25,r24
 321 00a2 9830      		cpi r25,lo8(8)
 322 00a4 00F4      		brsh .L12
 778:tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 323               		.loc 1 778 9 is_stmt 1 view .LVU82
 324               		.loc 1 778 18 is_stmt 0 view .LVU83
 325 00a6 8770      		andi r24,lo8(7)
 326               	.LVL28:
 327               		.loc 1 778 9 view .LVU84
 328 00a8 91E0      		ldi r25,lo8(1)
 329 00aa 00C0      		rjmp 2f
 330               		1:
 331 00ac 990F      		lsl r25
 332               		2:
 333 00ae 8A95      		dec r24
 334 00b0 02F4      		brpl 1b
 335 00b2 892F      		mov r24,r25
 336 00b4 0E94 0000 		call add_mods
 337               	.LVL29:
 779:tmk_core/common/action.c ****         send_keyboard_report();
 338               		.loc 1 779 9 is_stmt 1 view .LVU85
 339 00b8 00C0      		rjmp .L42
 340               	.LVL30:
 341               	.L12:
 780:tmk_core/common/action.c ****     }
 781:tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 342               		.loc 1 781 10 view .LVU86
 343               		.loc 1 781 13 is_stmt 0 view .LVU87
 344 00ba 9BE5      		ldi r25,lo8(91)
 345 00bc 980F      		add r25,r24
 346 00be 9330      		cpi r25,lo8(3)
 347 00c0 00F4      		brsh .L13
 782:tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 348               		.loc 1 782 9 is_stmt 1 view .LVU88
 349 00c2 853A      		cpi r24,lo8(-91)
 350 00c4 01F0      		breq .L16
 351               		.loc 1 782 26 is_stmt 0 discriminator 1 view .LVU89
 352 00c6 863A      		cpi r24,lo8(-90)
 353 00c8 01F0      		breq .L17
 354               		.loc 1 782 26 view .LVU90
 355 00ca 83E8      		ldi r24,lo8(-125)
 356 00cc 90E0      		ldi r25,0
 357               	.LVL31:
 358               	.L14:
 359               		.loc 1 782 9 discriminator 12 view .LVU91
 360 00ce 0C94 0000 		jmp host_system_send
 361               	.LVL32:
 362               	.L16:
 363               		.loc 1 782 9 view .LVU92
 364 00d2 81E8      		ldi r24,lo8(-127)
 365 00d4 90E0      		ldi r25,0
 366               	.LVL33:
 367               		.loc 1 782 9 view .LVU93
 368 00d6 00C0      		rjmp .L14
 369               	.LVL34:
 370               	.L17:
 371               		.loc 1 782 26 view .LVU94
 372 00d8 82E8      		ldi r24,lo8(-126)
 373 00da 90E0      		ldi r25,0
 374               	.LVL35:
 375               		.loc 1 782 26 view .LVU95
 376 00dc 00C0      		rjmp .L14
 377               	.LVL36:
 378               	.L13:
 783:tmk_core/common/action.c ****     }
 784:tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 379               		.loc 1 784 10 is_stmt 1 view .LVU96
 380               		.loc 1 784 13 is_stmt 0 view .LVU97
 381 00de 98E5      		ldi r25,lo8(88)
 382 00e0 980F      		add r25,r24
 383 00e2 9731      		cpi r25,lo8(23)
 384 00e4 00F0      		brlo .+2
 385 00e6 00C0      		rjmp .L4
 785:tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 386               		.loc 1 785 9 is_stmt 1 view .LVU98
 387 00e8 883A      		cpi r24,lo8(-88)
 388 00ea 01F4      		brne .+2
 389 00ec 00C0      		rjmp .L18
 390               		.loc 1 785 28 is_stmt 0 discriminator 1 view .LVU99
 391 00ee 893A      		cpi r24,lo8(-87)
 392 00f0 01F4      		brne .+2
 393 00f2 00C0      		rjmp .L19
 394               		.loc 1 785 28 discriminator 3 view .LVU100
 395 00f4 8A3A      		cpi r24,lo8(-86)
 396 00f6 01F4      		brne .+2
 397 00f8 00C0      		rjmp .L20
 398               		.loc 1 785 28 discriminator 5 view .LVU101
 399 00fa 8B3A      		cpi r24,lo8(-85)
 400 00fc 01F4      		brne .+2
 401 00fe 00C0      		rjmp .L21
 402               		.loc 1 785 28 discriminator 7 view .LVU102
 403 0100 8C3A      		cpi r24,lo8(-84)
 404 0102 01F4      		brne .+2
 405 0104 00C0      		rjmp .L22
 406               		.loc 1 785 28 discriminator 9 view .LVU103
 407 0106 8B3B      		cpi r24,lo8(-69)
 408 0108 01F4      		brne .+2
 409 010a 00C0      		rjmp .L23
 410               		.loc 1 785 28 discriminator 11 view .LVU104
 411 010c 8C3B      		cpi r24,lo8(-68)
 412 010e 01F4      		brne .+2
 413 0110 00C0      		rjmp .L24
 414               		.loc 1 785 28 discriminator 13 view .LVU105
 415 0112 8D3A      		cpi r24,lo8(-83)
 416 0114 01F4      		brne .+2
 417 0116 00C0      		rjmp .L25
 418               		.loc 1 785 28 discriminator 15 view .LVU106
 419 0118 803B      		cpi r24,lo8(-80)
 420 011a 01F4      		brne .+2
 421 011c 00C0      		rjmp .L26
 422               		.loc 1 785 28 discriminator 17 view .LVU107
 423 011e 8E3A      		cpi r24,lo8(-82)
 424 0120 01F4      		brne .+2
 425 0122 00C0      		rjmp .L27
 426               		.loc 1 785 28 discriminator 19 view .LVU108
 427 0124 8F3A      		cpi r24,lo8(-81)
 428 0126 01F4      		brne .+2
 429 0128 00C0      		rjmp .L28
 430               		.loc 1 785 28 discriminator 21 view .LVU109
 431 012a 813B      		cpi r24,lo8(-79)
 432 012c 01F4      		brne .+2
 433 012e 00C0      		rjmp .L29
 434               		.loc 1 785 28 discriminator 23 view .LVU110
 435 0130 823B      		cpi r24,lo8(-78)
 436 0132 01F4      		brne .+2
 437 0134 00C0      		rjmp .L30
 438               		.loc 1 785 28 discriminator 25 view .LVU111
 439 0136 833B      		cpi r24,lo8(-77)
 440 0138 01F4      		brne .+2
 441 013a 00C0      		rjmp .L31
 442               		.loc 1 785 28 discriminator 27 view .LVU112
 443 013c 843B      		cpi r24,lo8(-76)
 444 013e 01F4      		brne .+2
 445 0140 00C0      		rjmp .L32
 446               		.loc 1 785 28 discriminator 29 view .LVU113
 447 0142 853B      		cpi r24,lo8(-75)
 448 0144 01F4      		brne .+2
 449 0146 00C0      		rjmp .L33
 450               		.loc 1 785 28 discriminator 31 view .LVU114
 451 0148 863B      		cpi r24,lo8(-74)
 452 014a 01F4      		brne .+2
 453 014c 00C0      		rjmp .L34
 454               		.loc 1 785 28 discriminator 33 view .LVU115
 455 014e 873B      		cpi r24,lo8(-73)
 456 0150 01F4      		brne .+2
 457 0152 00C0      		rjmp .L35
 458               		.loc 1 785 28 discriminator 35 view .LVU116
 459 0154 883B      		cpi r24,lo8(-72)
 460 0156 01F4      		brne .+2
 461 0158 00C0      		rjmp .L36
 462               		.loc 1 785 28 discriminator 37 view .LVU117
 463 015a 893B      		cpi r24,lo8(-71)
 464 015c 01F4      		brne .+2
 465 015e 00C0      		rjmp .L37
 466               		.loc 1 785 28 discriminator 39 view .LVU118
 467 0160 8D3B      		cpi r24,lo8(-67)
 468 0162 01F4      		brne .+2
 469 0164 00C0      		rjmp .L38
 470               		.loc 1 785 28 discriminator 41 view .LVU119
 471 0166 8E3B      		cpi r24,lo8(-66)
 472 0168 01F4      		brne .+2
 473 016a 00C0      		rjmp .L39
 474               		.loc 1 785 28 discriminator 43 view .LVU120
 475 016c 8A3B      		cpi r24,lo8(-70)
 476 016e 01F4      		brne .+2
 477 0170 00C0      		rjmp .L40
 478               		.loc 1 785 28 view .LVU121
 479 0172 90E0      		ldi r25,0
 480 0174 80E0      		ldi r24,0
 481               	.LVL37:
 482               	.L15:
 483               		.loc 1 785 9 discriminator 92 view .LVU122
 484 0176 0C94 0000 		jmp host_consumer_send
 485               	.LVL38:
 486               	.L18:
 487               		.loc 1 785 9 view .LVU123
 488 017a 82EE      		ldi r24,lo8(-30)
 489 017c 90E0      		ldi r25,0
 490               	.LVL39:
 491               		.loc 1 785 9 view .LVU124
 492 017e 00C0      		rjmp .L15
 493               	.LVL40:
 494               	.L19:
 495               		.loc 1 785 28 view .LVU125
 496 0180 89EE      		ldi r24,lo8(-23)
 497 0182 90E0      		ldi r25,0
 498               	.LVL41:
 499               		.loc 1 785 28 view .LVU126
 500 0184 00C0      		rjmp .L15
 501               	.LVL42:
 502               	.L20:
 503               		.loc 1 785 28 view .LVU127
 504 0186 8AEE      		ldi r24,lo8(-22)
 505 0188 90E0      		ldi r25,0
 506               	.LVL43:
 507               		.loc 1 785 28 view .LVU128
 508 018a 00C0      		rjmp .L15
 509               	.LVL44:
 510               	.L21:
 511               		.loc 1 785 28 view .LVU129
 512 018c 85EB      		ldi r24,lo8(-75)
 513 018e 90E0      		ldi r25,0
 514               	.LVL45:
 515               		.loc 1 785 28 view .LVU130
 516 0190 00C0      		rjmp .L15
 517               	.LVL46:
 518               	.L22:
 519               		.loc 1 785 28 view .LVU131
 520 0192 86EB      		ldi r24,lo8(-74)
 521 0194 90E0      		ldi r25,0
 522               	.LVL47:
 523               		.loc 1 785 28 view .LVU132
 524 0196 00C0      		rjmp .L15
 525               	.LVL48:
 526               	.L23:
 527               		.loc 1 785 28 view .LVU133
 528 0198 83EB      		ldi r24,lo8(-77)
 529 019a 90E0      		ldi r25,0
 530               	.LVL49:
 531               		.loc 1 785 28 view .LVU134
 532 019c 00C0      		rjmp .L15
 533               	.LVL50:
 534               	.L24:
 535               		.loc 1 785 28 view .LVU135
 536 019e 84EB      		ldi r24,lo8(-76)
 537 01a0 90E0      		ldi r25,0
 538               	.LVL51:
 539               		.loc 1 785 28 view .LVU136
 540 01a2 00C0      		rjmp .L15
 541               	.LVL52:
 542               	.L25:
 543               		.loc 1 785 28 view .LVU137
 544 01a4 87EB      		ldi r24,lo8(-73)
 545 01a6 90E0      		ldi r25,0
 546               	.LVL53:
 547               		.loc 1 785 28 view .LVU138
 548 01a8 00C0      		rjmp .L15
 549               	.LVL54:
 550               	.L26:
 551               		.loc 1 785 28 view .LVU139
 552 01aa 8CEC      		ldi r24,lo8(-52)
 553 01ac 90E0      		ldi r25,0
 554               	.LVL55:
 555               		.loc 1 785 28 view .LVU140
 556 01ae 00C0      		rjmp .L15
 557               	.LVL56:
 558               	.L27:
 559               		.loc 1 785 28 view .LVU141
 560 01b0 8DEC      		ldi r24,lo8(-51)
 561 01b2 90E0      		ldi r25,0
 562               	.LVL57:
 563               		.loc 1 785 28 view .LVU142
 564 01b4 00C0      		rjmp .L15
 565               	.LVL58:
 566               	.L28:
 567               		.loc 1 785 28 view .LVU143
 568 01b6 83E8      		ldi r24,lo8(-125)
 569 01b8 91E0      		ldi r25,lo8(1)
 570               	.LVL59:
 571               		.loc 1 785 28 view .LVU144
 572 01ba 00C0      		rjmp .L15
 573               	.LVL60:
 574               	.L29:
 575               		.loc 1 785 28 view .LVU145
 576 01bc 8AE8      		ldi r24,lo8(-118)
 577 01be 91E0      		ldi r25,lo8(1)
 578               	.LVL61:
 579               		.loc 1 785 28 view .LVU146
 580 01c0 00C0      		rjmp .L15
 581               	.LVL62:
 582               	.L30:
 583               		.loc 1 785 28 view .LVU147
 584 01c2 82E9      		ldi r24,lo8(-110)
 585 01c4 91E0      		ldi r25,lo8(1)
 586               	.LVL63:
 587               		.loc 1 785 28 view .LVU148
 588 01c6 00C0      		rjmp .L15
 589               	.LVL64:
 590               	.L31:
 591               		.loc 1 785 28 view .LVU149
 592 01c8 84E9      		ldi r24,lo8(-108)
 593 01ca 91E0      		ldi r25,lo8(1)
 594               	.LVL65:
 595               		.loc 1 785 28 view .LVU150
 596 01cc 00C0      		rjmp .L15
 597               	.LVL66:
 598               	.L32:
 599               		.loc 1 785 28 view .LVU151
 600 01ce 81E2      		ldi r24,lo8(33)
 601 01d0 92E0      		ldi r25,lo8(2)
 602               	.LVL67:
 603               		.loc 1 785 28 view .LVU152
 604 01d2 00C0      		rjmp .L15
 605               	.LVL68:
 606               	.L33:
 607               		.loc 1 785 28 view .LVU153
 608 01d4 83E2      		ldi r24,lo8(35)
 609 01d6 92E0      		ldi r25,lo8(2)
 610               	.LVL69:
 611               		.loc 1 785 28 view .LVU154
 612 01d8 00C0      		rjmp .L15
 613               	.LVL70:
 614               	.L34:
 615               		.loc 1 785 28 view .LVU155
 616 01da 84E2      		ldi r24,lo8(36)
 617 01dc 92E0      		ldi r25,lo8(2)
 618               	.LVL71:
 619               		.loc 1 785 28 view .LVU156
 620 01de 00C0      		rjmp .L15
 621               	.LVL72:
 622               	.L35:
 623               		.loc 1 785 28 view .LVU157
 624 01e0 85E2      		ldi r24,lo8(37)
 625 01e2 92E0      		ldi r25,lo8(2)
 626               	.LVL73:
 627               		.loc 1 785 28 view .LVU158
 628 01e4 00C0      		rjmp .L15
 629               	.LVL74:
 630               	.L36:
 631               		.loc 1 785 28 view .LVU159
 632 01e6 86E2      		ldi r24,lo8(38)
 633 01e8 92E0      		ldi r25,lo8(2)
 634               	.LVL75:
 635               		.loc 1 785 28 view .LVU160
 636 01ea 00C0      		rjmp .L15
 637               	.LVL76:
 638               	.L37:
 639               		.loc 1 785 28 view .LVU161
 640 01ec 87E2      		ldi r24,lo8(39)
 641 01ee 92E0      		ldi r25,lo8(2)
 642               	.LVL77:
 643               		.loc 1 785 28 view .LVU162
 644 01f0 00C0      		rjmp .L15
 645               	.LVL78:
 646               	.L38:
 647               		.loc 1 785 28 view .LVU163
 648 01f2 8FE6      		ldi r24,lo8(111)
 649 01f4 90E0      		ldi r25,0
 650               	.LVL79:
 651               		.loc 1 785 28 view .LVU164
 652 01f6 00C0      		rjmp .L15
 653               	.LVL80:
 654               	.L39:
 655               		.loc 1 785 28 view .LVU165
 656 01f8 80E7      		ldi r24,lo8(112)
 657 01fa 90E0      		ldi r25,0
 658               	.LVL81:
 659               		.loc 1 785 28 view .LVU166
 660 01fc 00C0      		rjmp .L15
 661               	.LVL82:
 662               	.L40:
 663               		.loc 1 785 28 view .LVU167
 664 01fe 8AE2      		ldi r24,lo8(42)
 665 0200 92E0      		ldi r25,lo8(2)
 666               	.LVL83:
 667               		.loc 1 785 28 view .LVU168
 668 0202 00C0      		rjmp .L15
 669               	.L4:
 670               	/* epilogue start */
 786:tmk_core/common/action.c ****     }
 787:tmk_core/common/action.c **** 
 788:tmk_core/common/action.c ****     #ifdef MOUSEKEY_ENABLE
 789:tmk_core/common/action.c ****       else if IS_MOUSEKEY(code) {
 790:tmk_core/common/action.c ****         mousekey_on(code);
 791:tmk_core/common/action.c ****         mousekey_send();
 792:tmk_core/common/action.c ****       }
 793:tmk_core/common/action.c ****     #endif
 794:tmk_core/common/action.c **** }
 671               		.loc 1 794 1 view .LVU169
 672 0204 0895      		ret
 673               		.cfi_endproc
 674               	.LFE19:
 676               		.section	.text.unregister_code,"ax",@progbits
 677               	.global	unregister_code
 679               	unregister_code:
 680               	.LVL84:
 681               	.LFB20:
 795:tmk_core/common/action.c **** 
 796:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 797:tmk_core/common/action.c ****  *
 798:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 799:tmk_core/common/action.c ****  */
 800:tmk_core/common/action.c **** void unregister_code(uint8_t code)
 801:tmk_core/common/action.c **** {
 682               		.loc 1 801 1 is_stmt 1 view -0
 683               		.cfi_startproc
 684               	/* prologue: function */
 685               	/* frame size = 0 */
 686               	/* stack size = 0 */
 687               	.L__stack_usage = 0
 802:tmk_core/common/action.c ****     if (code == KC_NO) {
 688               		.loc 1 802 5 view .LVU171
 689               		.loc 1 802 8 is_stmt 0 view .LVU172
 690 0000 8823      		tst r24
 691 0002 01F4      		brne .+2
 692 0004 00C0      		rjmp .L43
 803:tmk_core/common/action.c ****         return;
 804:tmk_core/common/action.c ****     }
 805:tmk_core/common/action.c **** 
 806:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 807:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 693               		.loc 1 807 10 is_stmt 1 view .LVU173
 694               		.loc 1 807 13 is_stmt 0 view .LVU174
 695 0006 8238      		cpi r24,lo8(-126)
 696 0008 01F4      		brne .L46
 808:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 809:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 810:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK))) return;
 697               		.loc 1 810 9 is_stmt 1 view .LVU175
 698               		.loc 1 810 15 is_stmt 0 view .LVU176
 699 000a 0E94 0000 		call host_keyboard_leds
 700               	.LVL85:
 701               		.loc 1 810 12 view .LVU177
 702 000e 81FF      		sbrs r24,1
 703 0010 00C0      		rjmp .L43
 811:tmk_core/common/action.c **** #endif
 812:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 704               		.loc 1 812 9 is_stmt 1 view .LVU178
 705 0012 89E3      		ldi r24,lo8(57)
 706 0014 0E94 0000 		call add_key
 707               	.LVL86:
 813:tmk_core/common/action.c ****         send_keyboard_report();
 708               		.loc 1 813 9 view .LVU179
 709 0018 0E94 0000 		call send_keyboard_report
 710               	.LVL87:
 814:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 711               		.loc 1 814 9 view .LVU180
 712 001c 89E3      		ldi r24,lo8(57)
 713               	.L62:
 815:tmk_core/common/action.c ****         send_keyboard_report();
 816:tmk_core/common/action.c ****     }
 817:tmk_core/common/action.c **** 
 818:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 819:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 820:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_NUM_LOCK))) return;
 821:tmk_core/common/action.c **** #endif
 822:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 823:tmk_core/common/action.c ****         send_keyboard_report();
 824:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 714               		.loc 1 824 9 is_stmt 0 view .LVU181
 715 001e 0E94 0000 		call del_key
 716               	.LVL88:
 717               	.L63:
 825:tmk_core/common/action.c ****         send_keyboard_report();
 718               		.loc 1 825 9 is_stmt 1 view .LVU182
 719 0022 0C94 0000 		jmp send_keyboard_report
 720               	.LVL89:
 721               	.L46:
 818:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 722               		.loc 1 818 10 view .LVU183
 818:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 723               		.loc 1 818 13 is_stmt 0 view .LVU184
 724 0026 8338      		cpi r24,lo8(-125)
 725 0028 01F4      		brne .L48
 820:tmk_core/common/action.c **** #endif
 726               		.loc 1 820 9 is_stmt 1 view .LVU185
 820:tmk_core/common/action.c **** #endif
 727               		.loc 1 820 15 is_stmt 0 view .LVU186
 728 002a 0E94 0000 		call host_keyboard_leds
 729               	.LVL90:
 820:tmk_core/common/action.c **** #endif
 730               		.loc 1 820 12 view .LVU187
 731 002e 80FF      		sbrs r24,0
 732 0030 00C0      		rjmp .L43
 822:tmk_core/common/action.c ****         send_keyboard_report();
 733               		.loc 1 822 9 is_stmt 1 view .LVU188
 734 0032 83E5      		ldi r24,lo8(83)
 735 0034 0E94 0000 		call add_key
 736               	.LVL91:
 823:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 737               		.loc 1 823 9 view .LVU189
 738 0038 0E94 0000 		call send_keyboard_report
 739               	.LVL92:
 824:tmk_core/common/action.c ****         send_keyboard_report();
 740               		.loc 1 824 9 view .LVU190
 741 003c 83E5      		ldi r24,lo8(83)
 742 003e 00C0      		rjmp .L62
 743               	.LVL93:
 744               	.L48:
 826:tmk_core/common/action.c ****     }
 827:tmk_core/common/action.c **** 
 828:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 745               		.loc 1 828 10 view .LVU191
 746               		.loc 1 828 13 is_stmt 0 view .LVU192
 747 0040 8438      		cpi r24,lo8(-124)
 748 0042 01F4      		brne .L49
 829:tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 830:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK))) return;
 749               		.loc 1 830 9 is_stmt 1 view .LVU193
 750               		.loc 1 830 15 is_stmt 0 view .LVU194
 751 0044 0E94 0000 		call host_keyboard_leds
 752               	.LVL94:
 753               		.loc 1 830 12 view .LVU195
 754 0048 82FF      		sbrs r24,2
 755 004a 00C0      		rjmp .L43
 831:tmk_core/common/action.c **** #endif
 832:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 756               		.loc 1 832 9 is_stmt 1 view .LVU196
 757 004c 87E4      		ldi r24,lo8(71)
 758 004e 0E94 0000 		call add_key
 759               	.LVL95:
 833:tmk_core/common/action.c ****         send_keyboard_report();
 760               		.loc 1 833 9 view .LVU197
 761 0052 0E94 0000 		call send_keyboard_report
 762               	.LVL96:
 834:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 763               		.loc 1 834 9 view .LVU198
 764 0056 87E4      		ldi r24,lo8(71)
 765 0058 00C0      		rjmp .L62
 766               	.LVL97:
 767               	.L49:
 835:tmk_core/common/action.c ****         send_keyboard_report();
 836:tmk_core/common/action.c ****     }
 837:tmk_core/common/action.c **** #endif
 838:tmk_core/common/action.c **** 
 839:tmk_core/common/action.c ****     else if IS_KEY(code) {
 768               		.loc 1 839 10 view .LVU199
 769               		.loc 1 839 13 is_stmt 0 view .LVU200
 770 005a 9CEF      		ldi r25,lo8(-4)
 771 005c 980F      		add r25,r24
 772 005e 913A      		cpi r25,lo8(-95)
 773 0060 00F0      		brlo .L62
 840:tmk_core/common/action.c ****         del_key(code);
 841:tmk_core/common/action.c ****         send_keyboard_report();
 842:tmk_core/common/action.c ****     }
 843:tmk_core/common/action.c ****     else if IS_MOD(code) {
 774               		.loc 1 843 10 is_stmt 1 view .LVU201
 775               		.loc 1 843 13 is_stmt 0 view .LVU202
 776 0062 90E2      		ldi r25,lo8(32)
 777 0064 980F      		add r25,r24
 778 0066 9830      		cpi r25,lo8(8)
 779 0068 00F4      		brsh .L51
 844:tmk_core/common/action.c ****         del_mods(MOD_BIT(code));
 780               		.loc 1 844 9 is_stmt 1 view .LVU203
 781               		.loc 1 844 18 is_stmt 0 view .LVU204
 782 006a 8770      		andi r24,lo8(7)
 783               	.LVL98:
 784               		.loc 1 844 9 view .LVU205
 785 006c 91E0      		ldi r25,lo8(1)
 786 006e 00C0      		rjmp 2f
 787               		1:
 788 0070 990F      		lsl r25
 789               		2:
 790 0072 8A95      		dec r24
 791 0074 02F4      		brpl 1b
 792 0076 892F      		mov r24,r25
 793 0078 0E94 0000 		call del_mods
 794               	.LVL99:
 845:tmk_core/common/action.c ****         send_keyboard_report();
 795               		.loc 1 845 9 is_stmt 1 view .LVU206
 796 007c 00C0      		rjmp .L63
 797               	.LVL100:
 798               	.L51:
 846:tmk_core/common/action.c ****     }
 847:tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 799               		.loc 1 847 10 view .LVU207
 800               		.loc 1 847 13 is_stmt 0 view .LVU208
 801 007e 9BE5      		ldi r25,lo8(91)
 802 0080 980F      		add r25,r24
 803 0082 9330      		cpi r25,lo8(3)
 804 0084 00F4      		brsh .L52
 848:tmk_core/common/action.c ****         host_system_send(0);
 805               		.loc 1 848 9 is_stmt 1 view .LVU209
 806 0086 90E0      		ldi r25,0
 807 0088 80E0      		ldi r24,0
 808               	.LVL101:
 809               		.loc 1 848 9 is_stmt 0 view .LVU210
 810 008a 0C94 0000 		jmp host_system_send
 811               	.LVL102:
 812               	.L52:
 849:tmk_core/common/action.c ****     }
 850:tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 813               		.loc 1 850 10 is_stmt 1 view .LVU211
 814               		.loc 1 850 13 is_stmt 0 view .LVU212
 815 008e 885A      		subi r24,lo8(-(88))
 816               	.LVL103:
 817               		.loc 1 850 13 view .LVU213
 818 0090 8731      		cpi r24,lo8(23)
 819 0092 00F4      		brsh .L43
 851:tmk_core/common/action.c ****         host_consumer_send(0);
 820               		.loc 1 851 9 is_stmt 1 view .LVU214
 821 0094 90E0      		ldi r25,0
 822 0096 80E0      		ldi r24,0
 823               	.LVL104:
 824               		.loc 1 851 9 is_stmt 0 view .LVU215
 825 0098 0C94 0000 		jmp host_consumer_send
 826               	.LVL105:
 827               	.L43:
 828               	/* epilogue start */
 852:tmk_core/common/action.c ****     }
 853:tmk_core/common/action.c ****     #ifdef MOUSEKEY_ENABLE
 854:tmk_core/common/action.c ****       else if IS_MOUSEKEY(code) {
 855:tmk_core/common/action.c ****         mousekey_off(code);
 856:tmk_core/common/action.c ****         mousekey_send();
 857:tmk_core/common/action.c ****       }
 858:tmk_core/common/action.c ****     #endif
 859:tmk_core/common/action.c **** }
 829               		.loc 1 859 1 view .LVU216
 830 009c 0895      		ret
 831               		.cfi_endproc
 832               	.LFE20:
 834               		.section	.text.tap_code,"ax",@progbits
 835               	.global	tap_code
 837               	tap_code:
 838               	.LVL106:
 839               	.LFB21:
 860:tmk_core/common/action.c **** 
 861:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 862:tmk_core/common/action.c ****  *
 863:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 864:tmk_core/common/action.c ****  */
 865:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 840               		.loc 1 865 29 is_stmt 1 view -0
 841               		.cfi_startproc
 842               		.loc 1 865 29 is_stmt 0 view .LVU218
 843 0000 CF93      		push r28
 844               	.LCFI4:
 845               		.cfi_def_cfa_offset 3
 846               		.cfi_offset 28, -2
 847               	/* prologue: function */
 848               	/* frame size = 0 */
 849               	/* stack size = 1 */
 850               	.L__stack_usage = 1
 851 0002 C82F      		mov r28,r24
 866:tmk_core/common/action.c ****   register_code(code);
 852               		.loc 1 866 3 is_stmt 1 view .LVU219
 853 0004 0E94 0000 		call register_code
 854               	.LVL107:
 867:tmk_core/common/action.c ****   if (code == KC_CAPS) {
 855               		.loc 1 867 3 view .LVU220
 856               		.loc 1 867 6 is_stmt 0 view .LVU221
 857 0008 C933      		cpi r28,lo8(57)
 858 000a 01F4      		brne .L66
 868:tmk_core/common/action.c ****     wait_ms(TAP_HOLD_CAPS_DELAY);
 859               		.loc 1 868 5 is_stmt 1 view .LVU222
 860               	.LVL108:
 861               	.LBB28:
 862               	.LBI28:
 166:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** {
 863               		.loc 2 166 1 view .LVU223
 864               	.LBB29:
 168:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 865               		.loc 2 168 2 view .LVU224
 172:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 866               		.loc 2 172 2 view .LVU225
 173:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 867               		.loc 2 173 2 view .LVU226
 174:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 868               		.loc 2 174 2 view .LVU227
 184:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	#endif
 869               		.loc 2 184 3 view .LVU228
 870               		.loc 2 187 2 view .LVU229
 871 000c 2FEF      		ldi r18,lo8(255999)
 872 000e 87EE      		ldi r24,hi8(255999)
 873 0010 93E0      		ldi r25,hlo8(255999)
 874 0012 2150      	1:	subi r18,1
 875 0014 8040      		sbci r24,0
 876 0016 9040      		sbci r25,0
 877 0018 01F4      		brne 1b
 878 001a 00C0      		rjmp .
 879 001c 0000      		nop
 880               	.LVL109:
 881               	.L66:
 882               		.loc 2 187 2 is_stmt 0 view .LVU230
 883               	.LBE29:
 884               	.LBE28:
 869:tmk_core/common/action.c ****   } else {
 870:tmk_core/common/action.c ****     wait_ms(TAP_CODE_DELAY);
 871:tmk_core/common/action.c ****   }
 872:tmk_core/common/action.c ****   unregister_code(code);
 885               		.loc 1 872 3 is_stmt 1 view .LVU231
 886 001e 8C2F      		mov r24,r28
 887               	/* epilogue start */
 873:tmk_core/common/action.c **** }
 888               		.loc 1 873 1 is_stmt 0 view .LVU232
 889 0020 CF91      		pop r28
 890               	.LVL110:
 872:tmk_core/common/action.c **** }
 891               		.loc 1 872 3 view .LVU233
 892 0022 0C94 0000 		jmp unregister_code
 893               	.LVL111:
 872:tmk_core/common/action.c **** }
 894               		.loc 1 872 3 view .LVU234
 895               		.cfi_endproc
 896               	.LFE21:
 898               		.section	.text.register_mods,"ax",@progbits
 899               	.global	register_mods
 901               	register_mods:
 902               	.LVL112:
 903               	.LFB22:
 874:tmk_core/common/action.c **** 
 875:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 876:tmk_core/common/action.c ****  *
 877:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 878:tmk_core/common/action.c ****  */
 879:tmk_core/common/action.c **** void register_mods(uint8_t mods)
 880:tmk_core/common/action.c **** {
 904               		.loc 1 880 1 is_stmt 1 view -0
 905               		.cfi_startproc
 906               	/* prologue: function */
 907               	/* frame size = 0 */
 908               	/* stack size = 0 */
 909               	.L__stack_usage = 0
 881:tmk_core/common/action.c ****     if (mods) {
 910               		.loc 1 881 5 view .LVU236
 911               		.loc 1 881 8 is_stmt 0 view .LVU237
 912 0000 8823      		tst r24
 913 0002 01F0      		breq .L67
 882:tmk_core/common/action.c ****         add_mods(mods);
 914               		.loc 1 882 9 is_stmt 1 view .LVU238
 915 0004 0E94 0000 		call add_mods
 916               	.LVL113:
 883:tmk_core/common/action.c ****         send_keyboard_report();
 917               		.loc 1 883 9 view .LVU239
 918 0008 0C94 0000 		jmp send_keyboard_report
 919               	.LVL114:
 920               	.L67:
 921               	/* epilogue start */
 884:tmk_core/common/action.c ****     }
 885:tmk_core/common/action.c **** }
 922               		.loc 1 885 1 is_stmt 0 view .LVU240
 923 000c 0895      		ret
 924               		.cfi_endproc
 925               	.LFE22:
 927               		.section	.text.unregister_mods,"ax",@progbits
 928               	.global	unregister_mods
 930               	unregister_mods:
 931               	.LVL115:
 932               	.LFB23:
 886:tmk_core/common/action.c **** 
 887:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 888:tmk_core/common/action.c ****  *
 889:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 890:tmk_core/common/action.c ****  */
 891:tmk_core/common/action.c **** void unregister_mods(uint8_t mods)
 892:tmk_core/common/action.c **** {
 933               		.loc 1 892 1 is_stmt 1 view -0
 934               		.cfi_startproc
 935               	/* prologue: function */
 936               	/* frame size = 0 */
 937               	/* stack size = 0 */
 938               	.L__stack_usage = 0
 893:tmk_core/common/action.c ****     if (mods) {
 939               		.loc 1 893 5 view .LVU242
 940               		.loc 1 893 8 is_stmt 0 view .LVU243
 941 0000 8823      		tst r24
 942 0002 01F0      		breq .L69
 894:tmk_core/common/action.c ****         del_mods(mods);
 943               		.loc 1 894 9 is_stmt 1 view .LVU244
 944 0004 0E94 0000 		call del_mods
 945               	.LVL116:
 895:tmk_core/common/action.c ****         send_keyboard_report();
 946               		.loc 1 895 9 view .LVU245
 947 0008 0C94 0000 		jmp send_keyboard_report
 948               	.LVL117:
 949               	.L69:
 950               	/* epilogue start */
 896:tmk_core/common/action.c ****     }
 897:tmk_core/common/action.c **** }
 951               		.loc 1 897 1 is_stmt 0 view .LVU246
 952 000c 0895      		ret
 953               		.cfi_endproc
 954               	.LFE23:
 956               		.section	.text.process_action,"ax",@progbits
 957               	.global	process_action
 959               	process_action:
 960               	.LVL118:
 961               	.LFB18:
 201:tmk_core/common/action.c ****     keyevent_t event = record->event;
 962               		.loc 1 201 1 is_stmt 1 view -0
 963               		.cfi_startproc
 201:tmk_core/common/action.c ****     keyevent_t event = record->event;
 964               		.loc 1 201 1 is_stmt 0 view .LVU248
 965 0000 BF92      		push r11
 966               	.LCFI5:
 967               		.cfi_def_cfa_offset 3
 968               		.cfi_offset 11, -2
 969 0002 CF92      		push r12
 970               	.LCFI6:
 971               		.cfi_def_cfa_offset 4
 972               		.cfi_offset 12, -3
 973 0004 DF92      		push r13
 974               	.LCFI7:
 975               		.cfi_def_cfa_offset 5
 976               		.cfi_offset 13, -4
 977 0006 EF92      		push r14
 978               	.LCFI8:
 979               		.cfi_def_cfa_offset 6
 980               		.cfi_offset 14, -5
 981 0008 FF92      		push r15
 982               	.LCFI9:
 983               		.cfi_def_cfa_offset 7
 984               		.cfi_offset 15, -6
 985 000a 0F93      		push r16
 986               	.LCFI10:
 987               		.cfi_def_cfa_offset 8
 988               		.cfi_offset 16, -7
 989 000c 1F93      		push r17
 990               	.LCFI11:
 991               		.cfi_def_cfa_offset 9
 992               		.cfi_offset 17, -8
 993 000e CF93      		push r28
 994               	.LCFI12:
 995               		.cfi_def_cfa_offset 10
 996               		.cfi_offset 28, -9
 997 0010 DF93      		push r29
 998               	.LCFI13:
 999               		.cfi_def_cfa_offset 11
 1000               		.cfi_offset 29, -10
 1001               	/* prologue: function */
 1002               	/* frame size = 0 */
 1003               	/* stack size = 9 */
 1004               	.L__stack_usage = 9
 1005 0012 6C01      		movw r12,r24
 1006 0014 D62F      		mov r29,r22
 201:tmk_core/common/action.c ****     keyevent_t event = record->event;
 1007               		.loc 1 201 1 view .LVU249
 1008 0016 C72F      		mov r28,r23
 202:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 1009               		.loc 1 202 5 is_stmt 1 view .LVU250
 1010               	.LVL119:
 204:tmk_core/common/action.c **** #endif
 1011               		.loc 1 204 5 view .LVU251
 204:tmk_core/common/action.c **** #endif
 1012               		.loc 1 204 36 is_stmt 0 view .LVU252
 1013 0018 FC01      		movw r30,r24
 1014 001a 0581      		ldd r16,Z+5
 1015 001c 0295      		swap r16
 1016 001e 0F70      		andi r16,lo8(15)
 1017               	.LVL120:
 207:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 1018               		.loc 1 207 5 is_stmt 1 view .LVU253
 207:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 1019               		.loc 1 207 14 is_stmt 0 view .LVU254
 1020 0020 1281      		ldd r17,Z+2
 207:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 1021               		.loc 1 207 8 view .LVU255
 1022 0022 1111      		cpse r17,__zero_reg__
 209:tmk_core/common/action.c ****     }
 1023               		.loc 1 209 9 is_stmt 1 view .LVU256
 1024 0024 0E94 0000 		call clear_weak_mods
 1025               	.LVL121:
 1026               	.L72:
 213:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 1027               		.loc 1 213 5 view .LVU257
 215:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1028               		.loc 1 215 5 view .LVU258
 215:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1029               		.loc 1 215 9 is_stmt 0 view .LVU259
 1030 0028 0E94 0000 		call is_oneshot_layer_active
 1031               	.LVL122:
 215:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1032               		.loc 1 215 9 view .LVU260
 1033 002c E82E      		mov r14,r24
 215:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1034               		.loc 1 215 8 view .LVU261
 1035 002e 8823      		tst r24
 1036 0030 01F0      		breq .L73
 215:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1037               		.loc 1 215 35 discriminator 1 view .LVU262
 1038 0032 1123      		tst r17
 1039 0034 01F0      		breq .L156
 215:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1040               		.loc 1 215 55 discriminator 2 view .LVU263
 1041 0036 80E2      		ldi r24,lo8(32)
 215:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1042               		.loc 1 215 55 discriminator 2 view .LVU264
 1043 0038 8D0F      		add r24,r29
 215:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1044               		.loc 1 215 52 discriminator 2 view .LVU265
 1045 003a 8830      		cpi r24,lo8(8)
 1046 003c 00F0      		brlo .L156
 216:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 1047               		.loc 1 216 9 is_stmt 1 view .LVU266
 1048 003e 82E0      		ldi r24,lo8(2)
 1049 0040 0E94 0000 		call clear_oneshot_layer_state
 1050               	.LVL123:
 217:tmk_core/common/action.c ****     }
 1051               		.loc 1 217 9 view .LVU267
 217:tmk_core/common/action.c ****     }
 1052               		.loc 1 217 31 is_stmt 0 view .LVU268
 1053 0044 0E94 0000 		call is_oneshot_layer_active
 1054               	.LVL124:
 217:tmk_core/common/action.c ****     }
 1055               		.loc 1 217 9 view .LVU269
 1056 0048 91E0      		ldi r25,lo8(1)
 1057 004a E82E      		mov r14,r24
 1058 004c E926      		eor r14,r25
 1059               	.LVL125:
 1060               	.L73:
 221:tmk_core/common/action.c ****         /* Key and Mods */
 1061               		.loc 1 221 5 is_stmt 1 view .LVU270
 221:tmk_core/common/action.c ****         /* Key and Mods */
 1062               		.loc 1 221 24 is_stmt 0 view .LVU271
 1063 004e BC2E      		mov r11,r28
 1064 0050 B294      		swap r11
 1065 0052 9FE0      		ldi r25,lo8(15)
 1066 0054 B922      		and r11,r25
 221:tmk_core/common/action.c ****         /* Key and Mods */
 1067               		.loc 1 221 5 view .LVU272
 1068 0056 EB2D      		mov r30,r11
 1069 0058 F0E0      		ldi r31,0
 1070 005a E050      		subi r30,lo8(-(gs(.L76)))
 1071 005c F040      		sbci r31,hi8(-(gs(.L76)))
 1072 005e 0C94 0000 		jmp __tablejump2__
 1073               		.section	.jumptables.gcc.process_action,"a",@progbits
 1074               		.p2align	1
 1075               	.L76:
 1076 0000 0000      		.word gs(.L84)
 1077 0002 0000      		.word gs(.L84)
 1078 0004 0000      		.word gs(.L83)
 1079 0006 0000      		.word gs(.L83)
 1080 0008 0000      		.word gs(.L82)
 1081 000a 0000      		.word gs(.L74)
 1082 000c 0000      		.word gs(.L74)
 1083 000e 0000      		.word gs(.L74)
 1084 0010 0000      		.word gs(.L81)
 1085 0012 0000      		.word gs(.L80)
 1086 0014 0000      		.word gs(.L79)
 1087 0016 0000      		.word gs(.L79)
 1088 0018 0000      		.word gs(.L78)
 1089 001a 0000      		.word gs(.L77)
 1090 001c 0000      		.word gs(.L74)
 1091 001e 0000      		.word gs(.L75)
 1092               		.section	.text.process_action
 1093               	.LVL126:
 1094               	.L156:
 213:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 1095               		.loc 1 213 10 view .LVU273
 1096 0062 E12C      		mov r14,__zero_reg__
 1097 0064 00C0      		rjmp .L73
 1098               	.LVL127:
 1099               	.L84:
 1100               	.LBB30:
 226:tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 1101               		.loc 1 226 17 is_stmt 1 view .LVU274
 1102 0066 0C2F      		mov r16,r28
 1103               	.LVL128:
 226:tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 1104               		.loc 1 226 17 is_stmt 0 view .LVU275
 1105 0068 0F70      		andi r16,lo8(15)
 226:tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 1106               		.loc 1 226 48 view .LVU276
 1107 006a C07F      		andi r28,lo8(-16)
 1108               	.LVL129:
 226:tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 1109               		.loc 1 226 25 view .LVU277
 1110 006c 01F0      		breq .L85
 226:tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 1111               		.loc 1 226 25 discriminator 2 view .LVU278
 1112 006e 0295      		swap r16
 1113 0070 007F      		andi r16,lo8(-16)
 1114               	.L85:
 1115               	.LVL130:
 228:tmk_core/common/action.c ****                     if (mods) {
 1116               		.loc 1 228 17 is_stmt 1 discriminator 4 view .LVU279
 228:tmk_core/common/action.c ****                     if (mods) {
 1117               		.loc 1 228 20 is_stmt 0 discriminator 4 view .LVU280
 1118 0072 1123      		tst r17
 1119 0074 01F0      		breq .L86
 229:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1120               		.loc 1 229 21 is_stmt 1 view .LVU281
 229:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1121               		.loc 1 229 24 is_stmt 0 view .LVU282
 1122 0076 0023      		tst r16
 1123 0078 01F0      		breq .L185
 230:tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 1124               		.loc 1 230 25 is_stmt 1 view .LVU283
 230:tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 1125               		.loc 1 230 29 is_stmt 0 view .LVU284
 1126 007a 80E2      		ldi r24,lo8(32)
 1127 007c 8D0F      		add r24,r29
 230:tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 1128               		.loc 1 230 28 view .LVU285
 1129 007e 8830      		cpi r24,lo8(8)
 1130 0080 00F0      		brlo .L88
 230:tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 1131               		.loc 1 230 53 discriminator 1 view .LVU286
 1132 0082 D111      		cpse r29,__zero_reg__
 1133 0084 00C0      		rjmp .L89
 1134               	.L88:
 234:tmk_core/common/action.c ****                         } else {
 1135               		.loc 1 234 29 is_stmt 1 view .LVU287
 1136 0086 802F      		mov r24,r16
 1137 0088 0E94 0000 		call add_mods
 1138               	.LVL131:
 1139               	.L90:
 238:tmk_core/common/action.c ****                     }
 1140               		.loc 1 238 25 view .LVU288
 1141 008c 0E94 0000 		call send_keyboard_report
 1142               	.LVL132:
 240:tmk_core/common/action.c ****                 } else {
 1143               		.loc 1 240 21 view .LVU289
 1144               	.L185:
 240:tmk_core/common/action.c ****                 } else {
 1145               		.loc 1 240 21 is_stmt 0 view .LVU290
 1146               	.LBE30:
 519:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 1147               		.loc 1 519 75 is_stmt 1 view .LVU291
 520:tmk_core/common/action.c ****                         } else {
 1148               		.loc 1 520 29 view .LVU292
 1149 0090 8D2F      		mov r24,r29
 1150 0092 0E94 0000 		call register_code
 1151               	.LVL133:
 1152 0096 00C0      		rjmp .L74
 1153               	.LVL134:
 1154               	.L89:
 1155               	.LBB31:
 236:tmk_core/common/action.c ****                         }
 1156               		.loc 1 236 29 view .LVU293
 1157 0098 802F      		mov r24,r16
 1158 009a 0E94 0000 		call add_weak_mods
 1159               	.LVL135:
 1160 009e 00C0      		rjmp .L90
 1161               	.L86:
 242:tmk_core/common/action.c ****                     if (mods) {
 1162               		.loc 1 242 21 view .LVU294
 1163 00a0 8D2F      		mov r24,r29
 1164 00a2 0E94 0000 		call unregister_code
 1165               	.LVL136:
 243:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1166               		.loc 1 243 21 view .LVU295
 243:tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1167               		.loc 1 243 24 is_stmt 0 view .LVU296
 1168 00a6 0023      		tst r16
 1169 00a8 01F0      		breq .L74
 244:tmk_core/common/action.c ****                             del_mods(mods);
 1170               		.loc 1 244 25 is_stmt 1 view .LVU297
 244:tmk_core/common/action.c ****                             del_mods(mods);
 1171               		.loc 1 244 29 is_stmt 0 view .LVU298
 1172 00aa 80E2      		ldi r24,lo8(32)
 1173 00ac 8D0F      		add r24,r29
 244:tmk_core/common/action.c ****                             del_mods(mods);
 1174               		.loc 1 244 28 view .LVU299
 1175 00ae 8830      		cpi r24,lo8(8)
 1176 00b0 00F0      		brlo .L92
 244:tmk_core/common/action.c ****                             del_mods(mods);
 1177               		.loc 1 244 53 discriminator 1 view .LVU300
 1178 00b2 D111      		cpse r29,__zero_reg__
 1179 00b4 00C0      		rjmp .L93
 1180               	.L92:
 245:tmk_core/common/action.c ****                         } else {
 1181               		.loc 1 245 29 is_stmt 1 view .LVU301
 1182 00b6 802F      		mov r24,r16
 1183 00b8 0E94 0000 		call del_mods
 1184               	.LVL137:
 1185               	.L94:
 249:tmk_core/common/action.c ****                     }
 1186               		.loc 1 249 25 view .LVU302
 1187 00bc 0E94 0000 		call send_keyboard_report
 1188               	.LVL138:
 1189               	.L74:
 249:tmk_core/common/action.c ****                     }
 1190               		.loc 1 249 25 is_stmt 0 view .LVU303
 1191               	.LBE31:
 652:tmk_core/common/action.c ****         case ACT_LAYER:
 1192               		.loc 1 652 5 is_stmt 1 view .LVU304
 1193 00c0 2B2D      		mov r18,r11
 1194 00c2 2850      		subi r18,8
 1195 00c4 330B      		sbc r19,r19
 1196 00c6 2430      		cpi r18,4
 1197 00c8 3105      		cpc r19,__zero_reg__
 1198 00ca 00F4      		brsh .L151
 659:tmk_core/common/action.c ****             break;
 1199               		.loc 1 659 13 view .LVU305
 1200 00cc 0E94 0000 		call host_keyboard_leds
 1201               	.LVL139:
 1202 00d0 0E94 0000 		call led_set
 1203               	.LVL140:
 660:tmk_core/common/action.c ****         default:
 1204               		.loc 1 660 13 view .LVU306
 1205               	.L151:
 695:tmk_core/common/action.c ****         record->event.pressed = false;
 1206               		.loc 1 695 5 view .LVU307
 695:tmk_core/common/action.c ****         record->event.pressed = false;
 1207               		.loc 1 695 8 is_stmt 0 view .LVU308
 1208 00d4 EE20      		tst r14
 1209 00d6 01F4      		brne .+2
 1210 00d8 00C0      		rjmp .L71
 695:tmk_core/common/action.c ****         record->event.pressed = false;
 1211               		.loc 1 695 33 discriminator 1 view .LVU309
 1212 00da 0E94 0000 		call get_oneshot_layer_state
 1213               	.LVL141:
 695:tmk_core/common/action.c ****         record->event.pressed = false;
 1214               		.loc 1 695 28 discriminator 1 view .LVU310
 1215 00de 80FD      		sbrc r24,0
 1216 00e0 00C0      		rjmp .L71
 696:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1217               		.loc 1 696 9 is_stmt 1 view .LVU311
 696:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1218               		.loc 1 696 31 is_stmt 0 view .LVU312
 1219 00e2 F601      		movw r30,r12
 1220 00e4 1282      		std Z+2,__zero_reg__
 697:tmk_core/common/action.c ****         process_record(record);
 1221               		.loc 1 697 9 is_stmt 1 view .LVU313
 1222 00e6 0E94 0000 		call get_oneshot_layer
 1223               	.LVL142:
 1224 00ea 0E94 0000 		call layer_on
 1225               	.LVL143:
 698:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 1226               		.loc 1 698 9 view .LVU314
 1227 00ee C601      		movw r24,r12
 1228 00f0 0E94 0000 		call process_record
 1229               	.LVL144:
 699:tmk_core/common/action.c ****     }
 1230               		.loc 1 699 9 view .LVU315
 1231 00f4 0E94 0000 		call get_oneshot_layer
 1232               	.LVL145:
 1233               	/* epilogue start */
 702:tmk_core/common/action.c **** 
 1234               		.loc 1 702 1 is_stmt 0 view .LVU316
 1235 00f8 DF91      		pop r29
 1236               	.LVL146:
 702:tmk_core/common/action.c **** 
 1237               		.loc 1 702 1 view .LVU317
 1238 00fa CF91      		pop r28
 702:tmk_core/common/action.c **** 
 1239               		.loc 1 702 1 view .LVU318
 1240 00fc 1F91      		pop r17
 1241 00fe 0F91      		pop r16
 1242 0100 FF90      		pop r15
 1243 0102 EF90      		pop r14
 1244               	.LVL147:
 702:tmk_core/common/action.c **** 
 1245               		.loc 1 702 1 view .LVU319
 1246 0104 DF90      		pop r13
 1247 0106 CF90      		pop r12
 1248               	.LVL148:
 702:tmk_core/common/action.c **** 
 1249               		.loc 1 702 1 view .LVU320
 1250 0108 BF90      		pop r11
 699:tmk_core/common/action.c ****     }
 1251               		.loc 1 699 9 view .LVU321
 1252 010a 0C94 0000 		jmp layer_off
 1253               	.LVL149:
 1254               	.L93:
 1255               	.LBB32:
 247:tmk_core/common/action.c ****                         }
 1256               		.loc 1 247 29 is_stmt 1 view .LVU322
 1257 010e 802F      		mov r24,r16
 1258 0110 0E94 0000 		call del_weak_mods
 1259               	.LVL150:
 1260 0114 00C0      		rjmp .L94
 1261               	.LVL151:
 1262               	.L83:
 247:tmk_core/common/action.c ****                         }
 1263               		.loc 1 247 29 is_stmt 0 view .LVU323
 1264               	.LBE32:
 1265               	.LBB33:
 258:tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 1266               		.loc 1 258 17 is_stmt 1 view .LVU324
 1267 0116 FC2F      		mov r31,r28
 1268 0118 FF70      		andi r31,lo8(15)
 1269 011a FF2E      		mov r15,r31
 258:tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 1270               		.loc 1 258 48 is_stmt 0 view .LVU325
 1271 011c C07F      		andi r28,lo8(-16)
 1272               	.LVL152:
 258:tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 1273               		.loc 1 258 25 view .LVU326
 1274 011e C032      		cpi r28,lo8(32)
 1275 0120 01F0      		breq .L95
 258:tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 1276               		.loc 1 258 25 discriminator 2 view .LVU327
 1277 0122 F294      		swap r15
 1278 0124 80EF      		ldi r24,lo8(-16)
 1279 0126 F822      		and r15,r24
 1280               	.L95:
 1281               	.LVL153:
 260:tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 1282               		.loc 1 260 17 is_stmt 1 discriminator 4 view .LVU328
 1283 0128 DD23      		tst r29
 1284 012a 01F0      		breq .L96
 1285 012c D130      		cpi r29,lo8(1)
 1286 012e 01F0      		breq .L97
 315:tmk_core/common/action.c ****                             if (tap_count > 0) {
 1287               		.loc 1 315 25 view .LVU329
 315:tmk_core/common/action.c ****                             if (tap_count > 0) {
 1288               		.loc 1 315 28 is_stmt 0 view .LVU330
 1289 0130 1123      		tst r17
 1290 0132 01F0      		breq .L105
 316:tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 1291               		.loc 1 316 29 is_stmt 1 view .LVU331
 316:tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 1292               		.loc 1 316 32 is_stmt 0 view .LVU332
 1293 0134 0023      		tst r16
 1294 0136 01F0      		breq .L106
 318:tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 1295               		.loc 1 318 33 is_stmt 1 view .LVU333
 318:tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 1296               		.loc 1 318 37 is_stmt 0 view .LVU334
 1297 0138 F601      		movw r30,r12
 1298 013a 8581      		ldd r24,Z+5
 318:tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 1299               		.loc 1 318 36 view .LVU335
 1300 013c 80FF      		sbrs r24,0
 1301 013e 00C0      		rjmp .L185
 319:tmk_core/common/action.c ****                                     // ad hoc: set 0 to cancel tap
 1302               		.loc 1 319 80 is_stmt 1 view .LVU336
 321:tmk_core/common/action.c ****                                     register_mods(mods);
 1303               		.loc 1 321 37 view .LVU337
 321:tmk_core/common/action.c ****                                     register_mods(mods);
 1304               		.loc 1 321 55 is_stmt 0 view .LVU338
 1305 0140 8F70      		andi r24,lo8(15)
 1306 0142 8583      		std Z+5,r24
 322:tmk_core/common/action.c ****                                 } else
 1307               		.loc 1 322 37 is_stmt 1 view .LVU339
 1308 0144 00C0      		rjmp .L106
 1309               	.L96:
 264:tmk_core/common/action.c ****                             if (tap_count == 0) {
 1310               		.loc 1 264 25 view .LVU340
 264:tmk_core/common/action.c ****                             if (tap_count == 0) {
 1311               		.loc 1 264 28 is_stmt 0 view .LVU341
 1312 0146 1123      		tst r17
 1313 0148 01F0      		breq .L99
 265:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 1314               		.loc 1 265 29 is_stmt 1 view .LVU342
 265:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 1315               		.loc 1 265 32 is_stmt 0 view .LVU343
 1316 014a 0111      		cpse r16,__zero_reg__
 1317 014c 00C0      		rjmp .L100
 1318               	.L101:
 279:tmk_core/common/action.c ****                             }
 1319               		.loc 1 279 33 is_stmt 1 view .LVU344
 279:tmk_core/common/action.c ****                             }
 1320               		.loc 1 279 54 is_stmt 0 view .LVU345
 1321 014e 0E94 0000 		call get_oneshot_mods
 1322               	.LVL154:
 279:tmk_core/common/action.c ****                             }
 1323               		.loc 1 279 33 view .LVU346
 1324 0152 8F29      		or r24,r15
 1325               	.LVL155:
 1326               	.L184:
 279:tmk_core/common/action.c ****                             }
 1327               		.loc 1 279 33 view .LVU347
 1328               	.LBE33:
 443:tmk_core/common/action.c ****             } else {
 1329               		.loc 1 443 17 view .LVU348
 1330 0154 0E94 0000 		call register_mods
 1331               	.LVL156:
 1332 0158 00C0      		rjmp .L74
 1333               	.LVL157:
 1334               	.L100:
 1335               	.LBB36:
 268:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 1336               		.loc 1 268 36 is_stmt 1 view .LVU349
 268:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 1337               		.loc 1 268 39 is_stmt 0 view .LVU350
 1338 015a 0130      		cpi r16,lo8(1)
 1339 015c 01F4      		brne .L101
 269:tmk_core/common/action.c ****                                 set_oneshot_mods(mods | get_oneshot_mods());
 1340               		.loc 1 269 69 is_stmt 1 view .LVU351
 270:tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1341               		.loc 1 270 33 view .LVU352
 270:tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1342               		.loc 1 270 57 is_stmt 0 view .LVU353
 1343 015e 0E94 0000 		call get_oneshot_mods
 1344               	.LVL158:
 270:tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1345               		.loc 1 270 33 view .LVU354
 1346 0162 8F29      		or r24,r15
 1347 0164 0E94 0000 		call set_oneshot_mods
 1348               	.LVL159:
 1349 0168 00C0      		rjmp .L74
 1350               	.L99:
 282:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 1351               		.loc 1 282 29 is_stmt 1 view .LVU355
 282:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 1352               		.loc 1 282 32 is_stmt 0 view .LVU356
 1353 016a 0111      		cpse r16,__zero_reg__
 1354 016c 00C0      		rjmp .L102
 1355               	.L188:
 297:tmk_core/common/action.c ****                                 unregister_mods(mods);
 1356               		.loc 1 297 33 is_stmt 1 view .LVU357
 1357 016e 0E94 0000 		call clear_oneshot_mods
 1358               	.LVL160:
 298:tmk_core/common/action.c ****                             }
 1359               		.loc 1 298 33 view .LVU358
 1360               	.L108:
 341:tmk_core/common/action.c ****                                 unregister_mods(mods);
 1361               		.loc 1 341 71 view .LVU359
 342:tmk_core/common/action.c ****                             }
 1362               		.loc 1 342 33 view .LVU360
 1363 0172 8F2D      		mov r24,r15
 1364 0174 0E94 0000 		call unregister_mods
 1365               	.LVL161:
 1366 0178 00C0      		rjmp .L74
 1367               	.L102:
 285:tmk_core/common/action.c ****                                 // Retain Oneshot mods
 1368               		.loc 1 285 36 view .LVU361
 285:tmk_core/common/action.c ****                                 // Retain Oneshot mods
 1369               		.loc 1 285 39 is_stmt 0 view .LVU362
 1370 017a 0130      		cpi r16,lo8(1)
 1371 017c 01F4      		brne .+2
 1372 017e 00C0      		rjmp .L74
 1373 0180 00C0      		rjmp .L188
 1374               	.L97:
 304:tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 1375               		.loc 1 304 25 is_stmt 1 view .LVU363
 304:tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 1376               		.loc 1 304 28 is_stmt 0 view .LVU364
 1377 0182 1123      		tst r17
 1378 0184 01F0      		breq .L104
 305:tmk_core/common/action.c ****                                 register_mods(mods);
 1379               		.loc 1 305 29 is_stmt 1 view .LVU365
 305:tmk_core/common/action.c ****                                 register_mods(mods);
 1380               		.loc 1 305 32 is_stmt 0 view .LVU366
 1381 0186 0630      		cpi r16,lo8(6)
 1382 0188 00F0      		brlo .+2
 1383 018a 00C0      		rjmp .L74
 1384               	.L106:
 330:tmk_core/common/action.c ****                                 register_mods(mods);
 1385               		.loc 1 330 71 is_stmt 1 view .LVU367
 331:tmk_core/common/action.c ****                             }
 1386               		.loc 1 331 33 view .LVU368
 1387 018c 8F2D      		mov r24,r15
 1388 018e 00C0      		rjmp .L184
 1389               	.L104:
 309:tmk_core/common/action.c ****                                 unregister_mods(mods);
 1390               		.loc 1 309 29 view .LVU369
 309:tmk_core/common/action.c ****                                 unregister_mods(mods);
 1391               		.loc 1 309 32 is_stmt 0 view .LVU370
 1392 0190 0530      		cpi r16,lo8(5)
 1393 0192 00F0      		brlo .+2
 1394 0194 00C0      		rjmp .L74
 1395 0196 00C0      		rjmp .L108
 1396               	.L105:
 334:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 1397               		.loc 1 334 29 is_stmt 1 view .LVU371
 334:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 1398               		.loc 1 334 32 is_stmt 0 view .LVU372
 1399 0198 0023      		tst r16
 1400 019a 01F0      		breq .L108
 335:tmk_core/common/action.c ****                                 if (action.layer_tap.code == KC_CAPS) {
 1401               		.loc 1 335 75 is_stmt 1 view .LVU373
 336:tmk_core/common/action.c ****                                   wait_ms(TAP_HOLD_CAPS_DELAY);
 1402               		.loc 1 336 33 view .LVU374
 336:tmk_core/common/action.c ****                                   wait_ms(TAP_HOLD_CAPS_DELAY);
 1403               		.loc 1 336 36 is_stmt 0 view .LVU375
 1404 019c D933      		cpi r29,lo8(57)
 1405 019e 01F4      		brne .L143
 337:tmk_core/common/action.c ****                                 }
 1406               		.loc 1 337 35 is_stmt 1 view .LVU376
 1407               	.LVL162:
 1408               	.LBB34:
 1409               	.LBI34:
 166:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** {
 1410               		.loc 2 166 1 view .LVU377
 1411               	.LBB35:
 168:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1412               		.loc 2 168 2 view .LVU378
 172:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1413               		.loc 2 172 2 view .LVU379
 173:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1414               		.loc 2 173 2 view .LVU380
 174:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 1415               		.loc 2 174 2 view .LVU381
 184:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	#endif
 1416               		.loc 2 184 3 view .LVU382
 1417               		.loc 2 187 2 view .LVU383
 1418 01a0 FFEF      		ldi r31,lo8(255999)
 1419 01a2 27EE      		ldi r18,hi8(255999)
 1420 01a4 33E0      		ldi r19,hlo8(255999)
 1421 01a6 F150      	1:	subi r31,1
 1422 01a8 2040      		sbci r18,0
 1423 01aa 3040      		sbci r19,0
 1424 01ac 01F4      		brne 1b
 1425               	.LVL163:
 1426               	.L189:
 1427               		.loc 2 187 2 is_stmt 0 view .LVU384
 1428               	.LBE35:
 1429               	.LBE34:
 1430               	.LBE36:
 1431               	.LBB37:
 1432               	.LBB38:
 1433 01ae 00C0      		rjmp .
 1434 01b0 0000      		nop
 1435               	.L143:
 1436               	.LBE38:
 1437               	.LBE37:
 533:tmk_core/common/action.c ****                         } else {
 1438               		.loc 1 533 29 is_stmt 1 view .LVU385
 1439 01b2 8D2F      		mov r24,r29
 1440 01b4 0E94 0000 		call unregister_code
 1441               	.LVL164:
 1442 01b8 00C0      		rjmp .L74
 1443               	.L82:
 353:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1444               		.loc 1 353 13 view .LVU386
 353:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1445               		.loc 1 353 33 is_stmt 0 view .LVU387
 1446 01ba 8C2F      		mov r24,r28
 1447 01bc 8695      		lsr r24
 1448 01be 8695      		lsr r24
 1449 01c0 8370      		andi r24,lo8(3)
 1450 01c2 01F0      		breq .L110
 1451 01c4 8130      		cpi r24,lo8(1)
 1452 01c6 01F0      		breq .+2
 1453 01c8 00C0      		rjmp .L74
 362:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1454               		.loc 1 362 21 is_stmt 1 view .LVU388
 363:tmk_core/common/action.c ****                     } else {
 1455               		.loc 1 363 25 is_stmt 0 view .LVU389
 1456 01ca 8D2F      		mov r24,r29
 1457 01cc 9C2F      		mov r25,r28
 1458 01ce 9370      		andi r25,lo8(3)
 362:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1459               		.loc 1 362 24 view .LVU390
 1460 01d0 1111      		cpse r17,__zero_reg__
 1461 01d2 00C0      		rjmp .L187
 365:tmk_core/common/action.c ****                     }
 1462               		.loc 1 365 25 is_stmt 1 view .LVU391
 1463 01d4 90E0      		ldi r25,0
 1464 01d6 80E0      		ldi r24,0
 1465               	.L187:
 1466 01d8 0E94 0000 		call host_consumer_send
 1467               	.LVL165:
 1468 01dc 00C0      		rjmp .L74
 1469               	.L110:
 355:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1470               		.loc 1 355 21 view .LVU392
 356:tmk_core/common/action.c ****                     } else {
 1471               		.loc 1 356 25 is_stmt 0 view .LVU393
 1472 01de 8D2F      		mov r24,r29
 1473 01e0 9C2F      		mov r25,r28
 1474 01e2 9370      		andi r25,lo8(3)
 355:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1475               		.loc 1 355 24 view .LVU394
 1476 01e4 1111      		cpse r17,__zero_reg__
 1477 01e6 00C0      		rjmp .L182
 358:tmk_core/common/action.c ****                     }
 1478               		.loc 1 358 25 is_stmt 1 view .LVU395
 1479 01e8 90E0      		ldi r25,0
 1480 01ea 80E0      		ldi r24,0
 1481               	.L182:
 1482 01ec 0E94 0000 		call host_system_send
 1483               	.LVL166:
 1484 01f0 00C0      		rjmp .L74
 1485               	.L81:
 411:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1486               		.loc 1 411 13 view .LVU396
 411:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1487               		.loc 1 411 39 is_stmt 0 view .LVU397
 1488 01f2 8C2F      		mov r24,r28
 1489 01f4 8370      		andi r24,lo8(3)
 411:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1490               		.loc 1 411 16 view .LVU398
 1491 01f6 01F0      		breq .+2
 1492 01f8 00C0      		rjmp .L114
 413:tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 1493               		.loc 1 413 17 is_stmt 1 view .LVU399
 413:tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 1494               		.loc 1 413 20 is_stmt 0 view .LVU400
 1495 01fa 1111      		cpse r17,__zero_reg__
 1496 01fc 00C0      		rjmp .L74
 1497               	.LBB40:
 414:tmk_core/common/action.c ****                     layer_state_t bits = ((layer_state_t)action.layer_bitop.bits)<<shift;
 1498               		.loc 1 414 21 is_stmt 1 view .LVU401
 1499               	.LVL167:
 415:tmk_core/common/action.c ****                     layer_state_t mask = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf)<<shift)
 1500               		.loc 1 415 21 view .LVU402
 414:tmk_core/common/action.c ****                     layer_state_t bits = ((layer_state_t)action.layer_bitop.bits)<<shift;
 1501               		.loc 1 414 55 is_stmt 0 view .LVU403
 1502 01fe 4D2F      		mov r20,r29
 1503 0200 4295      		swap r20
 1504 0202 4695      		lsr r20
 1505 0204 4770      		andi r20,lo8(7)
 414:tmk_core/common/action.c ****                     layer_state_t bits = ((layer_state_t)action.layer_bitop.bits)<<shift;
 1506               		.loc 1 414 29 view .LVU404
 1507 0206 440F      		lsl r20
 1508 0208 440F      		lsl r20
 415:tmk_core/common/action.c ****                     layer_state_t mask = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf)<<shift)
 1509               		.loc 1 415 76 view .LVU405
 1510 020a 0D2F      		mov r16,r29
 1511               	.LVL168:
 415:tmk_core/common/action.c ****                     layer_state_t mask = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf)<<shift)
 1512               		.loc 1 415 76 view .LVU406
 1513 020c 0F70      		andi r16,lo8(15)
 415:tmk_core/common/action.c ****                     layer_state_t mask = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf)<<shift)
 1514               		.loc 1 415 43 view .LVU407
 1515 020e 10E0      		ldi r17,0
 1516               	.LVL169:
 415:tmk_core/common/action.c ****                     layer_state_t mask = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf)<<shift)
 1517               		.loc 1 415 43 view .LVU408
 1518 0210 30E0      		ldi r19,0
 1519 0212 20E0      		ldi r18,0
 415:tmk_core/common/action.c ****                     layer_state_t mask = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf)<<shift)
 1520               		.loc 1 415 35 view .LVU409
 1521 0214 042E      		mov r0,r20
 1522 0216 00C0      		rjmp 2f
 1523               		1:
 1524 0218 000F      		lsl r16
 1525 021a 111F      		rol r17
 1526 021c 221F      		rol r18
 1527 021e 331F      		rol r19
 1528               		2:
 1529 0220 0A94      		dec r0
 1530 0222 02F4      		brpl 1b
 1531               	.LVL170:
 416:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1532               		.loc 1 416 21 is_stmt 1 view .LVU410
 416:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1533               		.loc 1 416 101 is_stmt 0 view .LVU411
 1534 0224 60E0      		ldi r22,0
 1535 0226 70E0      		ldi r23,0
 1536 0228 CB01      		movw r24,r22
 1537 022a D4FF      		sbrs r29,4
 1538 022c 00C0      		rjmp .L115
 416:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1539               		.loc 1 416 92 discriminator 1 view .LVU412
 1540 022e 6FE0      		ldi r22,lo8(15)
 1541 0230 70E0      		ldi r23,0
 1542 0232 80E0      		ldi r24,0
 1543 0234 90E0      		ldi r25,0
 1544 0236 00C0      		rjmp 2f
 1545               		1:
 1546 0238 660F      		lsl r22
 1547 023a 771F      		rol r23
 1548 023c 881F      		rol r24
 1549 023e 991F      		rol r25
 1550               		2:
 1551 0240 4A95      		dec r20
 1552 0242 02F4      		brpl 1b
 416:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1553               		.loc 1 416 101 discriminator 1 view .LVU413
 1554 0244 6095      		com r22
 1555 0246 7095      		com r23
 1556 0248 8095      		com r24
 1557 024a 9095      		com r25
 1558               	.L115:
 1559               	.LVL171:
 417:tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1560               		.loc 1 417 21 is_stmt 1 discriminator 4 view .LVU414
 417:tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1561               		.loc 1 417 47 is_stmt 0 discriminator 4 view .LVU415
 1562 024c C695      		lsr r28
 1563 024e C695      		lsr r28
 1564               	.LVL172:
 417:tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1565               		.loc 1 417 47 discriminator 4 view .LVU416
 1566 0250 C370      		andi r28,lo8(3)
 1567 0252 602B      		or r22,r16
 1568               	.LVL173:
 417:tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1569               		.loc 1 417 47 discriminator 4 view .LVU417
 1570 0254 712B      		or r23,r17
 1571 0256 822B      		or r24,r18
 1572 0258 932B      		or r25,r19
 1573 025a C230      		cpi r28,lo8(2)
 1574 025c 01F0      		breq .L116
 1575 025e 00F4      		brsh .L117
 1576 0260 C130      		cpi r28,lo8(1)
 1577 0262 01F0      		breq .L118
 418:tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1578               		.loc 1 418 42 is_stmt 1 view .LVU418
 1579 0264 0E94 0000 		call default_layer_and
 1580               	.LVL174:
 418:tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1581               		.loc 1 418 74 view .LVU419
 418:tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1582               		.loc 1 418 25 is_stmt 0 view .LVU420
 1583 0268 00C0      		rjmp .L74
 1584               	.L118:
 419:tmk_core/common/action.c ****                         case OP_BIT_XOR: default_layer_xor(bits | mask); break;
 1585               		.loc 1 419 42 is_stmt 1 view .LVU421
 1586 026a 0E94 0000 		call default_layer_or
 1587               	.LVL175:
 419:tmk_core/common/action.c ****                         case OP_BIT_XOR: default_layer_xor(bits | mask); break;
 1588               		.loc 1 419 74 view .LVU422
 419:tmk_core/common/action.c ****                         case OP_BIT_XOR: default_layer_xor(bits | mask); break;
 1589               		.loc 1 419 25 is_stmt 0 view .LVU423
 1590 026e 00C0      		rjmp .L74
 1591               	.L116:
 420:tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_set(bits | mask); break;
 1592               		.loc 1 420 42 is_stmt 1 view .LVU424
 1593 0270 0E94 0000 		call default_layer_xor
 1594               	.LVL176:
 420:tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_set(bits | mask); break;
 1595               		.loc 1 420 74 view .LVU425
 420:tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_set(bits | mask); break;
 1596               		.loc 1 420 25 is_stmt 0 view .LVU426
 1597 0274 00C0      		rjmp .L74
 1598               	.L117:
 421:tmk_core/common/action.c ****                     }
 1599               		.loc 1 421 42 is_stmt 1 view .LVU427
 1600 0276 0E94 0000 		call default_layer_set
 1601               	.LVL177:
 421:tmk_core/common/action.c ****                     }
 1602               		.loc 1 421 74 view .LVU428
 421:tmk_core/common/action.c ****                     }
 1603               		.loc 1 421 25 is_stmt 0 view .LVU429
 1604 027a 00C0      		rjmp .L74
 1605               	.LVL178:
 1606               	.L114:
 421:tmk_core/common/action.c ****                     }
 1607               		.loc 1 421 25 view .LVU430
 1608               	.LBE40:
 426:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1609               		.loc 1 426 17 is_stmt 1 view .LVU431
 426:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1610               		.loc 1 426 21 is_stmt 0 view .LVU432
 1611 027c 8695      		lsr r24
 1612 027e 1123      		tst r17
 1613 0280 01F0      		breq .L120
 426:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1614               		.loc 1 426 21 discriminator 1 view .LVU433
 1615 0282 8C2F      		mov r24,r28
 1616 0284 8170      		andi r24,lo8(1)
 1617               	.L120:
 426:tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1618               		.loc 1 426 20 discriminator 4 view .LVU434
 1619 0286 8823      		tst r24
 1620 0288 01F4      		brne .+2
 1621 028a 00C0      		rjmp .L74
 1622               	.LBB41:
 428:tmk_core/common/action.c ****                     layer_state_t bits = ((layer_state_t)action.layer_bitop.bits)<<shift;
 1623               		.loc 1 428 21 is_stmt 1 view .LVU435
 1624               	.LVL179:
 429:tmk_core/common/action.c ****                     layer_state_t mask = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf)<<shift)
 1625               		.loc 1 429 21 view .LVU436
 428:tmk_core/common/action.c ****                     layer_state_t bits = ((layer_state_t)action.layer_bitop.bits)<<shift;
 1626               		.loc 1 428 55 is_stmt 0 view .LVU437
 1627 028c 4D2F      		mov r20,r29
 1628 028e 4295      		swap r20
 1629 0290 4695      		lsr r20
 1630 0292 4770      		andi r20,lo8(7)
 428:tmk_core/common/action.c ****                     layer_state_t bits = ((layer_state_t)action.layer_bitop.bits)<<shift;
 1631               		.loc 1 428 29 view .LVU438
 1632 0294 440F      		lsl r20
 1633 0296 440F      		lsl r20
 429:tmk_core/common/action.c ****                     layer_state_t mask = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf)<<shift)
 1634               		.loc 1 429 76 view .LVU439
 1635 0298 0D2F      		mov r16,r29
 1636               	.LVL180:
 429:tmk_core/common/action.c ****                     layer_state_t mask = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf)<<shift)
 1637               		.loc 1 429 76 view .LVU440
 1638 029a 0F70      		andi r16,lo8(15)
 429:tmk_core/common/action.c ****                     layer_state_t mask = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf)<<shift)
 1639               		.loc 1 429 43 view .LVU441
 1640 029c 10E0      		ldi r17,0
 1641               	.LVL181:
 429:tmk_core/common/action.c ****                     layer_state_t mask = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf)<<shift)
 1642               		.loc 1 429 43 view .LVU442
 1643 029e 30E0      		ldi r19,0
 1644 02a0 20E0      		ldi r18,0
 429:tmk_core/common/action.c ****                     layer_state_t mask = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf)<<shift)
 1645               		.loc 1 429 35 view .LVU443
 1646 02a2 042E      		mov r0,r20
 1647 02a4 00C0      		rjmp 2f
 1648               		1:
 1649 02a6 000F      		lsl r16
 1650 02a8 111F      		rol r17
 1651 02aa 221F      		rol r18
 1652 02ac 331F      		rol r19
 1653               		2:
 1654 02ae 0A94      		dec r0
 1655 02b0 02F4      		brpl 1b
 1656               	.LVL182:
 430:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1657               		.loc 1 430 21 is_stmt 1 view .LVU444
 430:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1658               		.loc 1 430 101 is_stmt 0 view .LVU445
 1659 02b2 60E0      		ldi r22,0
 1660 02b4 70E0      		ldi r23,0
 1661 02b6 CB01      		movw r24,r22
 1662 02b8 D4FF      		sbrs r29,4
 1663 02ba 00C0      		rjmp .L121
 430:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1664               		.loc 1 430 92 discriminator 1 view .LVU446
 1665 02bc 6FE0      		ldi r22,lo8(15)
 1666 02be 70E0      		ldi r23,0
 1667 02c0 80E0      		ldi r24,0
 1668 02c2 90E0      		ldi r25,0
 1669 02c4 00C0      		rjmp 2f
 1670               		1:
 1671 02c6 660F      		lsl r22
 1672 02c8 771F      		rol r23
 1673 02ca 881F      		rol r24
 1674 02cc 991F      		rol r25
 1675               		2:
 1676 02ce 4A95      		dec r20
 1677 02d0 02F4      		brpl 1b
 430:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1678               		.loc 1 430 101 discriminator 1 view .LVU447
 1679 02d2 6095      		com r22
 1680 02d4 7095      		com r23
 1681 02d6 8095      		com r24
 1682 02d8 9095      		com r25
 1683               	.L121:
 1684               	.LVL183:
 431:tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1685               		.loc 1 431 21 is_stmt 1 discriminator 4 view .LVU448
 431:tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1686               		.loc 1 431 47 is_stmt 0 discriminator 4 view .LVU449
 1687 02da C695      		lsr r28
 1688 02dc C695      		lsr r28
 1689               	.LVL184:
 431:tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1690               		.loc 1 431 47 discriminator 4 view .LVU450
 1691 02de C370      		andi r28,lo8(3)
 1692 02e0 602B      		or r22,r16
 1693               	.LVL185:
 431:tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1694               		.loc 1 431 47 discriminator 4 view .LVU451
 1695 02e2 712B      		or r23,r17
 1696 02e4 822B      		or r24,r18
 1697 02e6 932B      		or r25,r19
 1698 02e8 C230      		cpi r28,lo8(2)
 1699 02ea 01F0      		breq .L122
 1700 02ec 00F4      		brsh .L123
 1701 02ee C130      		cpi r28,lo8(1)
 1702 02f0 01F0      		breq .L124
 432:tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1703               		.loc 1 432 42 is_stmt 1 view .LVU452
 1704 02f2 0E94 0000 		call layer_and
 1705               	.LVL186:
 432:tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1706               		.loc 1 432 66 view .LVU453
 432:tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1707               		.loc 1 432 25 is_stmt 0 view .LVU454
 1708 02f6 00C0      		rjmp .L74
 1709               	.L124:
 433:tmk_core/common/action.c ****                         case OP_BIT_XOR: layer_xor(bits | mask); break;
 1710               		.loc 1 433 42 is_stmt 1 view .LVU455
 1711 02f8 0E94 0000 		call layer_or
 1712               	.LVL187:
 433:tmk_core/common/action.c ****                         case OP_BIT_XOR: layer_xor(bits | mask); break;
 1713               		.loc 1 433 66 view .LVU456
 433:tmk_core/common/action.c ****                         case OP_BIT_XOR: layer_xor(bits | mask); break;
 1714               		.loc 1 433 25 is_stmt 0 view .LVU457
 1715 02fc 00C0      		rjmp .L74
 1716               	.L122:
 434:tmk_core/common/action.c ****                         case OP_BIT_SET: layer_state_set(bits | mask); break;
 1717               		.loc 1 434 42 is_stmt 1 view .LVU458
 1718 02fe 0E94 0000 		call layer_xor
 1719               	.LVL188:
 434:tmk_core/common/action.c ****                         case OP_BIT_SET: layer_state_set(bits | mask); break;
 1720               		.loc 1 434 66 view .LVU459
 434:tmk_core/common/action.c ****                         case OP_BIT_SET: layer_state_set(bits | mask); break;
 1721               		.loc 1 434 25 is_stmt 0 view .LVU460
 1722 0302 00C0      		rjmp .L74
 1723               	.L123:
 435:tmk_core/common/action.c ****                     }
 1724               		.loc 1 435 42 is_stmt 1 view .LVU461
 1725 0304 0E94 0000 		call layer_state_set
 1726               	.LVL189:
 435:tmk_core/common/action.c ****                     }
 1727               		.loc 1 435 72 view .LVU462
 435:tmk_core/common/action.c ****                     }
 1728               		.loc 1 435 25 is_stmt 0 view .LVU463
 1729 0308 00C0      		rjmp .L74
 1730               	.LVL190:
 1731               	.L80:
 435:tmk_core/common/action.c ****                     }
 1732               		.loc 1 435 25 view .LVU464
 1733               	.LBE41:
 441:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1734               		.loc 1 441 13 is_stmt 1 view .LVU465
 1735 030a CF70      		andi r28,lo8(15)
 1736               	.LVL191:
 441:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1737               		.loc 1 441 16 is_stmt 0 view .LVU466
 1738 030c 1123      		tst r17
 1739 030e 01F0      		breq .L125
 442:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1740               		.loc 1 442 17 is_stmt 1 view .LVU467
 1741 0310 8C2F      		mov r24,r28
 1742 0312 0E94 0000 		call layer_on
 1743               	.LVL192:
 443:tmk_core/common/action.c ****             } else {
 1744               		.loc 1 443 17 view .LVU468
 1745 0316 8D2F      		mov r24,r29
 1746 0318 00C0      		rjmp .L184
 1747               	.L125:
 445:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1748               		.loc 1 445 17 view .LVU469
 1749 031a 8D2F      		mov r24,r29
 1750 031c 0E94 0000 		call unregister_mods
 1751               	.LVL193:
 446:tmk_core/common/action.c ****             }
 1752               		.loc 1 446 17 view .LVU470
 1753 0320 8C2F      		mov r24,r28
 1754               	.LVL194:
 1755               	.L181:
 536:tmk_core/common/action.c ****                         }
 1756               		.loc 1 536 29 is_stmt 0 view .LVU471
 1757 0322 0E94 0000 		call layer_off
 1758               	.LVL195:
 1759 0326 00C0      		rjmp .L74
 1760               	.L79:
 452:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1761               		.loc 1 452 13 is_stmt 1 view .LVU472
 1762 0328 D23F      		cpi r29,lo8(-14)
 1763 032a 01F0      		breq .L126
 1764 032c 00F4      		brsh .L127
 1765 032e D03F      		cpi r29,lo8(-16)
 1766 0330 01F0      		breq .L128
 1767 0332 D13F      		cpi r29,lo8(-15)
 1768 0334 01F0      		breq .L129
 1769               	.L130:
 517:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1770               		.loc 1 517 21 view .LVU473
 517:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1771               		.loc 1 517 24 is_stmt 0 view .LVU474
 1772 0336 1123      		tst r17
 1773 0338 01F4      		brne .+2
 1774 033a 00C0      		rjmp .L139
 518:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1775               		.loc 1 518 25 is_stmt 1 view .LVU475
 518:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1776               		.loc 1 518 28 is_stmt 0 view .LVU476
 1777 033c 0111      		cpse r16,__zero_reg__
 1778 033e 00C0      		rjmp .L185
 522:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1779               		.loc 1 522 76 is_stmt 1 view .LVU477
 523:tmk_core/common/action.c ****                         }
 1780               		.loc 1 523 29 view .LVU478
 1781 0340 8C2F      		mov r24,r28
 1782 0342 8F71      		andi r24,lo8(31)
 1783 0344 00C0      		rjmp .L183
 1784               	.L127:
 1785 0346 D33F      		cpi r29,lo8(-13)
 1786 0348 01F0      		breq .L131
 1787 034a D43F      		cpi r29,lo8(-12)
 1788 034c 01F4      		brne .L130
 503:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1789               		.loc 1 503 21 view .LVU479
 503:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1790               		.loc 1 503 24 is_stmt 0 view .LVU480
 1791 034e 1123      		tst r17
 1792 0350 01F0      		breq .L138
 504:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1793               		.loc 1 504 25 is_stmt 1 view .LVU481
 504:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1794               		.loc 1 504 50 is_stmt 0 view .LVU482
 1795 0352 CF71      		andi r28,lo8(31)
 1796               	.LVL196:
 504:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1797               		.loc 1 504 25 view .LVU483
 1798 0354 8C2F      		mov r24,r28
 1799 0356 0E94 0000 		call layer_on
 1800               	.LVL197:
 505:tmk_core/common/action.c ****                     } else {
 1801               		.loc 1 505 25 is_stmt 1 view .LVU484
 1802 035a 63E0      		ldi r22,lo8(3)
 1803 035c 8C2F      		mov r24,r28
 1804 035e 0E94 0000 		call set_oneshot_layer
 1805               	.LVL198:
 1806 0362 00C0      		rjmp .L74
 1807               	.LVL199:
 1808               	.L128:
 455:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1809               		.loc 1 455 21 view .LVU485
 455:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1810               		.loc 1 455 24 is_stmt 0 view .LVU486
 1811 0364 1123      		tst r17
 1812 0366 01F0      		breq .L133
 456:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1813               		.loc 1 456 25 is_stmt 1 view .LVU487
 456:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1814               		.loc 1 456 28 is_stmt 0 view .LVU488
 1815 0368 0530      		cpi r16,lo8(5)
 1816 036a 00F0      		brlo .+2
 1817 036c 00C0      		rjmp .L74
 1818               	.L134:
 457:tmk_core/common/action.c ****                         }
 1819               		.loc 1 457 29 is_stmt 1 view .LVU489
 1820 036e 8C2F      		mov r24,r28
 1821 0370 8F71      		andi r24,lo8(31)
 1822 0372 0E94 0000 		call layer_invert
 1823               	.LVL200:
 1824 0376 00C0      		rjmp .L74
 1825               	.L133:
 460:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1826               		.loc 1 460 25 view .LVU490
 460:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1827               		.loc 1 460 28 is_stmt 0 view .LVU491
 1828 0378 0630      		cpi r16,lo8(6)
 1829 037a 00F0      		brlo .+2
 1830 037c 00C0      		rjmp .L74
 1831 037e 00C0      		rjmp .L134
 1832               	.L129:
 466:tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1833               		.loc 1 466 21 is_stmt 1 view .LVU492
 1834 0380 8C2F      		mov r24,r28
 1835 0382 8F71      		andi r24,lo8(31)
 466:tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1836               		.loc 1 466 68 is_stmt 0 view .LVU493
 1837 0384 1123      		tst r17
 1838 0386 01F0      		breq .L181
 1839               	.L183:
 523:tmk_core/common/action.c ****                         }
 1840               		.loc 1 523 29 view .LVU494
 1841 0388 0E94 0000 		call layer_on
 1842               	.LVL201:
 1843 038c 00C0      		rjmp .L74
 1844               	.L126:
 470:tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 1845               		.loc 1 470 21 is_stmt 1 view .LVU495
 1846 038e 8C2F      		mov r24,r28
 1847 0390 8F71      		andi r24,lo8(31)
 470:tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 1848               		.loc 1 470 69 is_stmt 0 view .LVU496
 1849 0392 1123      		tst r17
 1850 0394 01F0      		breq .L183
 1851 0396 00C0      		rjmp .L181
 1852               	.L131:
 474:tmk_core/common/action.c ****                                     layer_clear();
 1853               		.loc 1 474 21 is_stmt 1 view .LVU497
 474:tmk_core/common/action.c ****                                     layer_clear();
 1854               		.loc 1 474 70 is_stmt 0 view .LVU498
 1855 0398 1123      		tst r17
 1856 039a 01F0      		breq .L137
 474:tmk_core/common/action.c ****                                     layer_clear();
 1857               		.loc 1 474 37 discriminator 1 view .LVU499
 1858 039c 8C2F      		mov r24,r28
 1859 039e 8F71      		andi r24,lo8(31)
 1860 03a0 0E94 0000 		call layer_move
 1861               	.LVL202:
 1862 03a4 00C0      		rjmp .L74
 1863               	.L137:
 475:tmk_core/common/action.c ****                     break;
 1864               		.loc 1 475 37 view .LVU500
 1865 03a6 0E94 0000 		call layer_clear
 1866               	.LVL203:
 1867 03aa 00C0      		rjmp .L74
 1868               	.L138:
 507:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1869               		.loc 1 507 25 is_stmt 1 view .LVU501
 1870 03ac 81E0      		ldi r24,lo8(1)
 1871 03ae 0E94 0000 		call clear_oneshot_layer_state
 1872               	.LVL204:
 508:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1873               		.loc 1 508 25 view .LVU502
 508:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1874               		.loc 1 508 28 is_stmt 0 view .LVU503
 1875 03b2 0230      		cpi r16,lo8(2)
 1876 03b4 00F4      		brsh .+2
 1877 03b6 00C0      		rjmp .L74
 509:tmk_core/common/action.c ****                         }
 1878               		.loc 1 509 29 is_stmt 1 view .LVU504
 1879 03b8 82E0      		ldi r24,lo8(2)
 1880 03ba 0E94 0000 		call clear_oneshot_layer_state
 1881               	.LVL205:
 1882 03be 00C0      		rjmp .L74
 1883               	.L139:
 526:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1884               		.loc 1 526 25 view .LVU505
 526:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1885               		.loc 1 526 28 is_stmt 0 view .LVU506
 1886 03c0 0023      		tst r16
 1887 03c2 01F0      		breq .L141
 527:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1888               		.loc 1 527 77 is_stmt 1 view .LVU507
 528:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1889               		.loc 1 528 29 view .LVU508
 528:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1890               		.loc 1 528 32 is_stmt 0 view .LVU509
 1891 03c4 D933      		cpi r29,lo8(57)
 1892 03c6 01F0      		breq .+2
 1893 03c8 00C0      		rjmp .L143
 529:tmk_core/common/action.c ****                             } else {
 1894               		.loc 1 529 33 is_stmt 1 view .LVU510
 1895               	.LVL206:
 1896               	.LBB42:
 1897               	.LBI37:
 166:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** {
 1898               		.loc 2 166 1 view .LVU511
 1899               	.LBB39:
 168:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1900               		.loc 2 168 2 view .LVU512
 172:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1901               		.loc 2 172 2 view .LVU513
 173:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1902               		.loc 2 173 2 view .LVU514
 174:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 
 1903               		.loc 2 174 2 view .LVU515
 184:/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/util/delay.h **** 	#endif
 1904               		.loc 2 184 3 view .LVU516
 1905               		.loc 2 187 2 view .LVU517
 1906 03ca 8FEF      		ldi r24,lo8(255999)
 1907 03cc 97EE      		ldi r25,hi8(255999)
 1908 03ce E3E0      		ldi r30,hlo8(255999)
 1909 03d0 8150      	1:	subi r24,1
 1910 03d2 9040      		sbci r25,0
 1911 03d4 E040      		sbci r30,0
 1912 03d6 01F4      		brne 1b
 1913 03d8 00C0      		rjmp .L189
 1914               	.LVL207:
 1915               	.L141:
 1916               		.loc 2 187 2 is_stmt 0 view .LVU518
 1917               	.LBE39:
 1918               	.LBE42:
 535:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 1919               		.loc 1 535 79 is_stmt 1 view .LVU519
 536:tmk_core/common/action.c ****                         }
 1920               		.loc 1 536 29 view .LVU520
 1921 03da 8C2F      		mov r24,r28
 1922 03dc 8F71      		andi r24,lo8(31)
 1923 03de 00C0      		rjmp .L181
 1924               	.L78:
 547:tmk_core/common/action.c ****             break;
 1925               		.loc 1 547 13 view .LVU521
 547:tmk_core/common/action.c ****             break;
 1926               		.loc 1 547 83 is_stmt 0 view .LVU522
 1927 03e0 4C2F      		mov r20,r28
 1928 03e2 4F70      		andi r20,lo8(15)
 547:tmk_core/common/action.c ****             break;
 1929               		.loc 1 547 13 view .LVU523
 1930 03e4 6D2F      		mov r22,r29
 1931 03e6 C601      		movw r24,r12
 1932 03e8 0E94 0000 		call action_get_macro
 1933               	.LVL208:
 1934 03ec 0E94 0000 		call action_macro_play
 1935               	.LVL209:
 548:tmk_core/common/action.c **** #endif
 1936               		.loc 1 548 13 is_stmt 1 view .LVU524
 1937 03f0 00C0      		rjmp .L74
 1938               	.L77:
 552:tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 1939               		.loc 1 552 13 view .LVU525
 552:tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 1940               		.loc 1 552 16 is_stmt 0 view .LVU526
 1941 03f2 1111      		cpse r17,__zero_reg__
 1942 03f4 00C0      		rjmp .L74
 553:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 1943               		.loc 1 553 17 is_stmt 1 view .LVU527
 553:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 1944               		.loc 1 553 41 is_stmt 0 view .LVU528
 1945 03f6 CF70      		andi r28,lo8(15)
 1946               	.LVL210:
 553:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 1947               		.loc 1 553 41 view .LVU529
 1948 03f8 C230      		cpi r28,lo8(2)
 1949 03fa 01F0      		breq .L144
 1950 03fc 00F4      		brsh .L145
 1951 03fe CC23      		tst r28
 1952 0400 01F0      		breq .L146
 1953 0402 C130      		cpi r28,lo8(1)
 1954 0404 01F0      		breq .+2
 1955 0406 00C0      		rjmp .L74
 558:tmk_core/common/action.c ****                         break;
 1956               		.loc 1 558 25 is_stmt 1 view .LVU530
 1957 0408 0E94 0000 		call backlight_decrease
 1958               	.LVL211:
 559:tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 1959               		.loc 1 559 25 view .LVU531
 1960 040c 00C0      		rjmp .L74
 1961               	.L145:
 1962 040e C430      		cpi r28,lo8(4)
 1963 0410 01F0      		breq .L148
 1964 0412 00F0      		brlo .L149
 570:tmk_core/common/action.c ****                         break;
 1965               		.loc 1 570 25 is_stmt 0 view .LVU532
 1966 0414 80E0      		ldi r24,0
 1967 0416 C530      		cpi r28,lo8(5)
 1968 0418 01F0      		breq .+2
 1969 041a 00C0      		rjmp .L74
 1970               	.L186:
 1971 041c 0E94 0000 		call backlight_level
 1972               	.LVL212:
 571:tmk_core/common/action.c ****                 }
 1973               		.loc 1 571 25 is_stmt 1 view .LVU533
 1974 0420 00C0      		rjmp .L74
 1975               	.L146:
 555:tmk_core/common/action.c ****                         break;
 1976               		.loc 1 555 25 view .LVU534
 1977 0422 0E94 0000 		call backlight_increase
 1978               	.LVL213:
 556:tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 1979               		.loc 1 556 25 view .LVU535
 1980 0426 00C0      		rjmp .L74
 1981               	.L144:
 561:tmk_core/common/action.c ****                         break;
 1982               		.loc 1 561 25 view .LVU536
 1983 0428 0E94 0000 		call backlight_toggle
 1984               	.LVL214:
 562:tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 1985               		.loc 1 562 25 view .LVU537
 1986 042c 00C0      		rjmp .L74
 1987               	.L149:
 564:tmk_core/common/action.c ****                         break;
 1988               		.loc 1 564 25 view .LVU538
 1989 042e 0E94 0000 		call backlight_step
 1990               	.LVL215:
 565:tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 1991               		.loc 1 565 25 view .LVU539
 1992 0432 00C0      		rjmp .L74
 1993               	.L148:
 567:tmk_core/common/action.c ****                         break;
 1994               		.loc 1 567 25 view .LVU540
 1995 0434 84E0      		ldi r24,lo8(4)
 1996 0436 00C0      		rjmp .L186
 1997               	.LVL216:
 1998               	.L75:
 643:tmk_core/common/action.c ****             break;
 1999               		.loc 1 643 13 view .LVU541
 643:tmk_core/common/action.c ****             break;
 2000               		.loc 1 643 64 is_stmt 0 view .LVU542
 2001 0438 4C2F      		mov r20,r28
 2002 043a 4F70      		andi r20,lo8(15)
 643:tmk_core/common/action.c ****             break;
 2003               		.loc 1 643 13 view .LVU543
 2004 043c 6D2F      		mov r22,r29
 2005 043e C601      		movw r24,r12
 2006 0440 0E94 0000 		call action_function
 2007               	.LVL217:
 644:tmk_core/common/action.c **** #endif
 2008               		.loc 1 644 13 is_stmt 1 view .LVU544
 2009 0444 00C0      		rjmp .L74
 2010               	.LVL218:
 2011               	.L71:
 2012               	/* epilogue start */
 702:tmk_core/common/action.c **** 
 2013               		.loc 1 702 1 is_stmt 0 view .LVU545
 2014 0446 DF91      		pop r29
 2015               	.LVL219:
 702:tmk_core/common/action.c **** 
 2016               		.loc 1 702 1 view .LVU546
 2017 0448 CF91      		pop r28
 702:tmk_core/common/action.c **** 
 2018               		.loc 1 702 1 view .LVU547
 2019 044a 1F91      		pop r17
 2020 044c 0F91      		pop r16
 2021 044e FF90      		pop r15
 2022 0450 EF90      		pop r14
 2023               	.LVL220:
 702:tmk_core/common/action.c **** 
 2024               		.loc 1 702 1 view .LVU548
 2025 0452 DF90      		pop r13
 2026 0454 CF90      		pop r12
 2027               	.LVL221:
 702:tmk_core/common/action.c **** 
 2028               		.loc 1 702 1 view .LVU549
 2029 0456 BF90      		pop r11
 2030 0458 0895      		ret
 2031               		.cfi_endproc
 2032               	.LFE18:
 2034               		.section	.text.process_record,"ax",@progbits
 2035               	.global	process_record
 2037               	process_record:
 2038               	.LVL222:
 2039               	.LFB17:
 179:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 2040               		.loc 1 179 1 is_stmt 1 view -0
 2041               		.cfi_startproc
 179:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 2042               		.loc 1 179 1 is_stmt 0 view .LVU551
 2043 0000 0F93      		push r16
 2044               	.LCFI14:
 2045               		.cfi_def_cfa_offset 3
 2046               		.cfi_offset 16, -2
 2047 0002 1F93      		push r17
 2048               	.LCFI15:
 2049               		.cfi_def_cfa_offset 4
 2050               		.cfi_offset 17, -3
 2051 0004 CF93      		push r28
 2052               	.LCFI16:
 2053               		.cfi_def_cfa_offset 5
 2054               		.cfi_offset 28, -4
 2055 0006 DF93      		push r29
 2056               	.LCFI17:
 2057               		.cfi_def_cfa_offset 6
 2058               		.cfi_offset 29, -5
 2059               	/* prologue: function */
 2060               	/* frame size = 0 */
 2061               	/* stack size = 4 */
 2062               	.L__stack_usage = 4
 2063 0008 EC01      		movw r28,r24
 180:tmk_core/common/action.c **** 
 2064               		.loc 1 180 5 is_stmt 1 view .LVU552
 2065               	.LBB45:
 2066               	.LBI45:
 2067               		.file 3 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** 
  25:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  26:tmk_core/common/keyboard.h **** extern "C" {
  27:tmk_core/common/keyboard.h **** #endif
  28:tmk_core/common/keyboard.h **** 
  29:tmk_core/common/keyboard.h **** /* key matrix position */
  30:tmk_core/common/keyboard.h **** typedef struct {
  31:tmk_core/common/keyboard.h ****     uint8_t col;
  32:tmk_core/common/keyboard.h ****     uint8_t row;
  33:tmk_core/common/keyboard.h **** } keypos_t;
  34:tmk_core/common/keyboard.h **** 
  35:tmk_core/common/keyboard.h **** /* key event */
  36:tmk_core/common/keyboard.h **** typedef struct {
  37:tmk_core/common/keyboard.h ****     keypos_t key;
  38:tmk_core/common/keyboard.h ****     bool     pressed;
  39:tmk_core/common/keyboard.h ****     uint16_t time;
  40:tmk_core/common/keyboard.h **** } keyevent_t;
  41:tmk_core/common/keyboard.h **** 
  42:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  43:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb)       ((keya).row == (keyb).row && (keya).col == (keyb).col)
  44:tmk_core/common/keyboard.h **** 
  45:tmk_core/common/keyboard.h **** /* Rules for No Event:
  46:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  47:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  48:tmk_core/common/keyboard.h ****  */
  49:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 2068               		.loc 3 49 20 view .LVU553
 2069               	.LBB46:
 2070               		.loc 3 49 51 view .LVU554
 2071               		.loc 3 49 74 is_stmt 0 view .LVU555
 2072 000a 8B81      		ldd r24,Y+3
 2073 000c 9C81      		ldd r25,Y+4
 2074               	.LVL223:
 2075               		.loc 3 49 74 view .LVU556
 2076 000e 892B      		or r24,r25
 2077 0010 01F0      		breq .L190
 2078 0012 8881      		ld r24,Y
 2079 0014 9981      		ldd r25,Y+1
 2080 0016 8923      		and r24,r25
 2081 0018 8F3F      		cpi r24,lo8(-1)
 2082 001a 01F4      		brne .L200
 2083               	.L190:
 2084               	/* epilogue start */
 2085               	.LBE46:
 2086               	.LBE45:
 194:tmk_core/common/action.c **** 
 2087               		.loc 1 194 1 view .LVU557
 2088 001c DF91      		pop r29
 2089 001e CF91      		pop r28
 2090               	.LVL224:
 194:tmk_core/common/action.c **** 
 2091               		.loc 1 194 1 view .LVU558
 2092 0020 1F91      		pop r17
 2093 0022 0F91      		pop r16
 2094 0024 0895      		ret
 2095               	.LVL225:
 2096               	.L200:
 182:tmk_core/common/action.c ****         return;
 2097               		.loc 1 182 5 is_stmt 1 view .LVU559
 182:tmk_core/common/action.c ****         return;
 2098               		.loc 1 182 9 is_stmt 0 view .LVU560
 2099 0026 CE01      		movw r24,r28
 2100 0028 0E94 0000 		call process_record_quantum
 2101               	.LVL226:
 182:tmk_core/common/action.c ****         return;
 2102               		.loc 1 182 7 view .LVU561
 2103 002c 8823      		tst r24
 2104 002e 01F0      		breq .L190
 185:tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 2105               		.loc 1 185 5 is_stmt 1 view .LVU562
 185:tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 2106               		.loc 1 185 23 is_stmt 0 view .LVU563
 2107 0030 6881      		ld r22,Y
 2108 0032 7981      		ldd r23,Y+1
 2109 0034 8A81      		ldd r24,Y+2
 2110 0036 0E94 0000 		call store_or_get_action
 2111               	.LVL227:
 2112 003a 8C01      		movw r16,r24
 2113               	.LVL228:
 186:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 2114               		.loc 1 186 23 is_stmt 1 view .LVU564
 186:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 2115               		.loc 1 186 25 view .LVU565
 188:tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 2116               		.loc 1 188 29 view .LVU566
 188:tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 2117               		.loc 1 188 31 view .LVU567
 2118 003c 0E94 0000 		call layer_debug
 2119               	.LVL229:
 189:tmk_core/common/action.c **** #endif
 2120               		.loc 1 189 37 view .LVU568
 189:tmk_core/common/action.c **** #endif
 2121               		.loc 1 189 39 view .LVU569
 2122 0040 0E94 0000 		call default_layer_debug
 2123               	.LVL230:
 191:tmk_core/common/action.c **** 
 2124               		.loc 1 191 15 view .LVU570
 193:tmk_core/common/action.c **** }
 2125               		.loc 1 193 5 view .LVU571
 193:tmk_core/common/action.c **** }
 2126               		.loc 1 193 5 is_stmt 0 view .LVU572
 2127 0044 B801      		movw r22,r16
 2128 0046 CE01      		movw r24,r28
 2129               	/* epilogue start */
 194:tmk_core/common/action.c **** 
 2130               		.loc 1 194 1 view .LVU573
 2131 0048 DF91      		pop r29
 2132 004a CF91      		pop r28
 2133               	.LVL231:
 194:tmk_core/common/action.c **** 
 2134               		.loc 1 194 1 view .LVU574
 2135 004c 1F91      		pop r17
 2136 004e 0F91      		pop r16
 2137               	.LVL232:
 193:tmk_core/common/action.c **** }
 2138               		.loc 1 193 5 view .LVU575
 2139 0050 0C94 0000 		jmp process_action
 2140               	.LVL233:
 193:tmk_core/common/action.c **** }
 2141               		.loc 1 193 5 view .LVU576
 2142               		.cfi_endproc
 2143               	.LFE17:
 2145               		.section	.text.process_record_nocache,"ax",@progbits
 2146               	.global	process_record_nocache
 2148               	process_record_nocache:
 2149               	.LVL234:
 2150               	.LFB14:
 133:tmk_core/common/action.c ****     disable_action_cache = true;
 2151               		.loc 1 133 1 is_stmt 1 view -0
 2152               		.cfi_startproc
 2153               	/* prologue: function */
 2154               	/* frame size = 0 */
 2155               	/* stack size = 0 */
 2156               	.L__stack_usage = 0
 134:tmk_core/common/action.c ****     process_record(record);
 2157               		.loc 1 134 5 view .LVU578
 134:tmk_core/common/action.c ****     process_record(record);
 2158               		.loc 1 134 26 is_stmt 0 view .LVU579
 2159 0000 21E0      		ldi r18,lo8(1)
 2160 0002 2093 0000 		sts disable_action_cache,r18
 135:tmk_core/common/action.c ****     disable_action_cache = false;
 2161               		.loc 1 135 5 is_stmt 1 view .LVU580
 2162 0006 0E94 0000 		call process_record
 2163               	.LVL235:
 136:tmk_core/common/action.c **** }
 2164               		.loc 1 136 5 view .LVU581
 136:tmk_core/common/action.c **** }
 2165               		.loc 1 136 26 is_stmt 0 view .LVU582
 2166 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 2167               	/* epilogue start */
 137:tmk_core/common/action.c **** #else
 2168               		.loc 1 137 1 view .LVU583
 2169 000e 0895      		ret
 2170               		.cfi_endproc
 2171               	.LFE14:
 2173               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 2174               	.global	clear_keyboard_but_mods_and_keys
 2176               	clear_keyboard_but_mods_and_keys:
 2177               	.LFB26:
 898:tmk_core/common/action.c **** 
 899:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 900:tmk_core/common/action.c ****  *
 901:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 902:tmk_core/common/action.c ****  */
 903:tmk_core/common/action.c **** void clear_keyboard(void)
 904:tmk_core/common/action.c **** {
 905:tmk_core/common/action.c ****     clear_mods();
 906:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 907:tmk_core/common/action.c **** }
 908:tmk_core/common/action.c **** 
 909:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 910:tmk_core/common/action.c ****  *
 911:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 912:tmk_core/common/action.c ****  */
 913:tmk_core/common/action.c **** void clear_keyboard_but_mods(void)
 914:tmk_core/common/action.c **** {
 915:tmk_core/common/action.c ****     clear_keys();
 916:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 917:tmk_core/common/action.c **** }
 918:tmk_core/common/action.c **** 
 919:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 920:tmk_core/common/action.c ****  *
 921:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 922:tmk_core/common/action.c ****  */
 923:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys()
 924:tmk_core/common/action.c **** {
 2178               		.loc 1 924 1 is_stmt 1 view -0
 2179               		.cfi_startproc
 2180               	/* prologue: function */
 2181               	/* frame size = 0 */
 2182               	/* stack size = 0 */
 2183               	.L__stack_usage = 0
 925:tmk_core/common/action.c ****     clear_weak_mods();
 2184               		.loc 1 925 5 view .LVU585
 2185 0000 0E94 0000 		call clear_weak_mods
 2186               	.LVL236:
 926:tmk_core/common/action.c ****     clear_macro_mods();
 2187               		.loc 1 926 5 view .LVU586
 2188 0004 0E94 0000 		call clear_macro_mods
 2189               	.LVL237:
 927:tmk_core/common/action.c ****     send_keyboard_report();
 2190               		.loc 1 927 5 view .LVU587
 2191 0008 0E94 0000 		call send_keyboard_report
 2192               	.LVL238:
 928:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 929:tmk_core/common/action.c ****     mousekey_clear();
 930:tmk_core/common/action.c ****     mousekey_send();
 931:tmk_core/common/action.c **** #endif
 932:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 933:tmk_core/common/action.c ****     host_system_send(0);
 2193               		.loc 1 933 5 view .LVU588
 2194 000c 90E0      		ldi r25,0
 2195 000e 80E0      		ldi r24,0
 2196 0010 0E94 0000 		call host_system_send
 2197               	.LVL239:
 934:tmk_core/common/action.c ****     host_consumer_send(0);
 2198               		.loc 1 934 5 view .LVU589
 2199 0014 90E0      		ldi r25,0
 2200 0016 80E0      		ldi r24,0
 2201 0018 0C94 0000 		jmp host_consumer_send
 2202               	.LVL240:
 2203               		.cfi_endproc
 2204               	.LFE26:
 2206               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 2207               	.global	clear_keyboard_but_mods
 2209               	clear_keyboard_but_mods:
 2210               	.LFB25:
 914:tmk_core/common/action.c ****     clear_keys();
 2211               		.loc 1 914 1 view -0
 2212               		.cfi_startproc
 2213               	/* prologue: function */
 2214               	/* frame size = 0 */
 2215               	/* stack size = 0 */
 2216               	.L__stack_usage = 0
 915:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 2217               		.loc 1 915 5 view .LVU591
 2218 0000 0E94 0000 		call clear_keys
 2219               	.LVL241:
 916:tmk_core/common/action.c **** }
 2220               		.loc 1 916 5 view .LVU592
 2221 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 2222               	.LVL242:
 2223               		.cfi_endproc
 2224               	.LFE25:
 2226               		.section	.text.clear_keyboard,"ax",@progbits
 2227               	.global	clear_keyboard
 2229               	clear_keyboard:
 2230               	.LFB24:
 904:tmk_core/common/action.c ****     clear_mods();
 2231               		.loc 1 904 1 view -0
 2232               		.cfi_startproc
 2233               	/* prologue: function */
 2234               	/* frame size = 0 */
 2235               	/* stack size = 0 */
 2236               	.L__stack_usage = 0
 905:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 2237               		.loc 1 905 5 view .LVU594
 2238 0000 0E94 0000 		call clear_mods
 2239               	.LVL243:
 906:tmk_core/common/action.c **** }
 2240               		.loc 1 906 5 view .LVU595
 2241 0004 0C94 0000 		jmp clear_keyboard_but_mods
 2242               	.LVL244:
 2243               		.cfi_endproc
 2244               	.LFE24:
 2246               		.section	.text.is_tap_action,"ax",@progbits
 2247               	.global	is_tap_action
 2249               	is_tap_action:
 2250               	.LVL245:
 2251               	.LFB28:
 935:tmk_core/common/action.c **** #endif
 936:tmk_core/common/action.c **** }
 937:tmk_core/common/action.c **** 
 938:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 939:tmk_core/common/action.c ****  *
 940:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 941:tmk_core/common/action.c ****  */
 942:tmk_core/common/action.c **** bool is_tap_key(keypos_t key)
 943:tmk_core/common/action.c **** {
 944:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 945:tmk_core/common/action.c ****     return is_tap_action(action);
 946:tmk_core/common/action.c **** }
 947:tmk_core/common/action.c **** 
 948:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 949:tmk_core/common/action.c ****  *
 950:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 951:tmk_core/common/action.c ****  */
 952:tmk_core/common/action.c **** bool is_tap_action(action_t action)
 953:tmk_core/common/action.c **** {
 2252               		.loc 1 953 1 view -0
 2253               		.cfi_startproc
 2254               	/* prologue: function */
 2255               	/* frame size = 0 */
 2256               	/* stack size = 0 */
 2257               	.L__stack_usage = 0
 954:tmk_core/common/action.c ****     switch (action.kind.id) {
 2258               		.loc 1 954 5 view .LVU597
 2259               		.loc 1 954 24 is_stmt 0 view .LVU598
 2260 0000 E92F      		mov r30,r25
 2261 0002 E295      		swap r30
 2262 0004 EF70      		andi r30,lo8(15)
 2263               		.loc 1 954 5 view .LVU599
 2264 0006 E250      		subi r30,lo8(-(-2))
 2265 0008 EE30      		cpi r30,lo8(14)
 2266 000a 00F4      		brsh .L214
 2267 000c F0E0      		ldi r31,0
 2268 000e E050      		subi r30,lo8(-(gs(.L208)))
 2269 0010 F040      		sbci r31,hi8(-(gs(.L208)))
 2270 0012 0C94 0000 		jmp __tablejump2__
 2271               		.section	.jumptables.gcc.is_tap_action,"a",@progbits
 2272               		.p2align	1
 2273               	.L208:
 2274 0000 0000      		.word gs(.L209)
 2275 0002 0000      		.word gs(.L209)
 2276 0004 0000      		.word gs(.L214)
 2277 0006 0000      		.word gs(.L214)
 2278 0008 0000      		.word gs(.L210)
 2279 000a 0000      		.word gs(.L214)
 2280 000c 0000      		.word gs(.L214)
 2281 000e 0000      		.word gs(.L214)
 2282 0010 0000      		.word gs(.L209)
 2283 0012 0000      		.word gs(.L209)
 2284 0014 0000      		.word gs(.L207)
 2285 0016 0000      		.word gs(.L214)
 2286 0018 0000      		.word gs(.L214)
 2287 001a 0000      		.word gs(.L207)
 2288               		.section	.text.is_tap_action
 2289               	.L209:
 955:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 956:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 957:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 958:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 959:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 2290               		.loc 1 959 13 is_stmt 1 view .LVU600
 2291 0016 803F      		cpi r24,lo8(-16)
 2292 0018 01F0      		breq .L217
 2293 001a 00F4      		brsh .L211
 2294 001c 883E      		cpi r24,lo8(-24)
 2295 001e 00F4      		brsh .L214
 2296               	.L217:
 960:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 961:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 962:tmk_core/common/action.c ****                 case OP_ONESHOT:
 963:tmk_core/common/action.c ****                     return true;
 2297               		.loc 1 963 28 is_stmt 0 view .LVU601
 2298 0020 81E0      		ldi r24,lo8(1)
 2299               	.LVL246:
 2300               	/* epilogue start */
 964:tmk_core/common/action.c ****             }
 965:tmk_core/common/action.c ****             return false;
 966:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 967:tmk_core/common/action.c ****             switch (action.swap.code) {
 968:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 969:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 970:tmk_core/common/action.c ****                     return true;
 971:tmk_core/common/action.c ****             }
 972:tmk_core/common/action.c ****             return false;
 973:tmk_core/common/action.c ****         case ACT_MACRO:
 974:tmk_core/common/action.c ****         case ACT_FUNCTION:
 975:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) { return true; }
 976:tmk_core/common/action.c ****             return false;
 977:tmk_core/common/action.c ****     }
 978:tmk_core/common/action.c ****     return false;
 979:tmk_core/common/action.c **** }
 2301               		.loc 1 979 1 view .LVU602
 2302 0022 0895      		ret
 2303               	.LVL247:
 2304               	.L211:
 2305               		.loc 1 979 1 view .LVU603
 2306 0024 843F      		cpi r24,lo8(-12)
 2307 0026 01F0      		breq .L217
 2308               	.L214:
 965:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2309               		.loc 1 965 20 view .LVU604
 2310 0028 80E0      		ldi r24,0
 2311               	.LVL248:
 965:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2312               		.loc 1 965 20 view .LVU605
 2313 002a 0895      		ret
 2314               	.LVL249:
 2315               	.L210:
 967:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 2316               		.loc 1 967 13 is_stmt 1 view .LVU606
 2317 002c 883E      		cpi r24,lo8(-24)
 2318 002e 00F0      		brlo .L217
 2319 0030 813F      		cpi r24,lo8(-15)
 2320 0032 01F4      		brne .L214
 2321 0034 00C0      		rjmp .L217
 2322               	.L207:
 975:tmk_core/common/action.c ****             return false;
 2323               		.loc 1 975 13 view .LVU607
 975:tmk_core/common/action.c ****             return false;
 2324               		.loc 1 975 16 is_stmt 0 view .LVU608
 2325 0036 93FB      		bst r25,3
 2326 0038 8827      		clr r24
 2327 003a 80F9      		bld r24,0
 2328               	.LVL250:
 975:tmk_core/common/action.c ****             return false;
 2329               		.loc 1 975 16 view .LVU609
 2330 003c 0895      		ret
 2331               		.cfi_endproc
 2332               	.LFE28:
 2334               		.section	.text.is_tap_key,"ax",@progbits
 2335               	.global	is_tap_key
 2337               	is_tap_key:
 2338               	.LVL251:
 2339               	.LFB27:
 943:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2340               		.loc 1 943 1 is_stmt 1 view -0
 2341               		.cfi_startproc
 2342               	/* prologue: function */
 2343               	/* frame size = 0 */
 2344               	/* stack size = 0 */
 2345               	.L__stack_usage = 0
 944:tmk_core/common/action.c ****     return is_tap_action(action);
 2346               		.loc 1 944 5 view .LVU611
 944:tmk_core/common/action.c ****     return is_tap_action(action);
 2347               		.loc 1 944 23 is_stmt 0 view .LVU612
 2348 0000 0E94 0000 		call layer_switch_get_action
 2349               	.LVL252:
 945:tmk_core/common/action.c **** }
 2350               		.loc 1 945 5 is_stmt 1 view .LVU613
 945:tmk_core/common/action.c **** }
 2351               		.loc 1 945 12 is_stmt 0 view .LVU614
 2352 0004 0C94 0000 		jmp is_tap_action
 2353               	.LVL253:
 2354               		.cfi_endproc
 2355               	.LFE27:
 2357               		.section	.text.debug_event,"ax",@progbits
 2358               	.global	debug_event
 2360               	debug_event:
 2361               	.LFB29:
 980:tmk_core/common/action.c **** 
 981:tmk_core/common/action.c **** 
 982:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 983:tmk_core/common/action.c ****  *
 984:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 985:tmk_core/common/action.c ****  */
 986:tmk_core/common/action.c **** void debug_event(keyevent_t event)
 987:tmk_core/common/action.c **** {
 2362               		.loc 1 987 1 is_stmt 1 view -0
 2363               		.cfi_startproc
 2364 0000 CF93      		push r28
 2365               	.LCFI18:
 2366               		.cfi_def_cfa_offset 3
 2367               		.cfi_offset 28, -2
 2368 0002 DF93      		push r29
 2369               	.LCFI19:
 2370               		.cfi_def_cfa_offset 4
 2371               		.cfi_offset 29, -3
 2372 0004 00D0      		rcall .
 2373 0006 00D0      		rcall .
 2374 0008 0F92      		push __tmp_reg__
 2375               	.LCFI20:
 2376               		.cfi_def_cfa_offset 9
 2377 000a CDB7      		in r28,__SP_L__
 2378 000c DEB7      		in r29,__SP_H__
 2379               	.LCFI21:
 2380               		.cfi_def_cfa_register 28
 2381               	/* prologue: function */
 2382               	/* frame size = 5 */
 2383               	/* stack size = 7 */
 2384               	.L__stack_usage = 7
 988:tmk_core/common/action.c ****     dprintf("%04X%c(%u)", (event.key.row<<8 | event.key.col), (event.pressed ? 'd' : 'u'), event.ti
 2385               		.loc 1 988 103 view .LVU616
 2386               	/* epilogue start */
 989:tmk_core/common/action.c **** }
 2387               		.loc 1 989 1 is_stmt 0 view .LVU617
 2388 000e 0F90      		pop __tmp_reg__
 2389 0010 0F90      		pop __tmp_reg__
 2390 0012 0F90      		pop __tmp_reg__
 2391 0014 0F90      		pop __tmp_reg__
 2392 0016 0F90      		pop __tmp_reg__
 2393 0018 DF91      		pop r29
 2394 001a CF91      		pop r28
 2395 001c 0895      		ret
 2396               		.cfi_endproc
 2397               	.LFE29:
 2399               		.section	.text.debug_record,"ax",@progbits
 2400               	.global	debug_record
 2402               	debug_record:
 2403               	.LFB30:
 990:tmk_core/common/action.c **** 
 991:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 992:tmk_core/common/action.c ****  *
 993:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 994:tmk_core/common/action.c ****  */
 995:tmk_core/common/action.c **** void debug_record(keyrecord_t record)
 996:tmk_core/common/action.c **** {
 2404               		.loc 1 996 1 is_stmt 1 view -0
 2405               		.cfi_startproc
 2406 0000 CF93      		push r28
 2407               	.LCFI22:
 2408               		.cfi_def_cfa_offset 3
 2409               		.cfi_offset 28, -2
 2410 0002 DF93      		push r29
 2411               	.LCFI23:
 2412               		.cfi_def_cfa_offset 4
 2413               		.cfi_offset 29, -3
 2414 0004 00D0      		rcall .
 2415 0006 00D0      		rcall .
 2416 0008 00D0      		rcall .
 2417               	.LCFI24:
 2418               		.cfi_def_cfa_offset 10
 2419 000a CDB7      		in r28,__SP_L__
 2420 000c DEB7      		in r29,__SP_H__
 2421               	.LCFI25:
 2422               		.cfi_def_cfa_register 28
 2423               	/* prologue: function */
 2424               	/* frame size = 6 */
 2425               	/* stack size = 8 */
 2426               	.L__stack_usage = 8
 997:tmk_core/common/action.c ****     debug_event(record.event);
 2427               		.loc 1 997 5 view .LVU619
 998:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 999:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2428               		.loc 1 999 77 view .LVU620
 2429               	/* epilogue start */
1000:tmk_core/common/action.c **** #endif
1001:tmk_core/common/action.c **** }
 2430               		.loc 1 1001 1 is_stmt 0 view .LVU621
 2431 000e 2696      		adiw r28,6
 2432 0010 0FB6      		in __tmp_reg__,__SREG__
 2433 0012 F894      		cli
 2434 0014 DEBF      		out __SP_H__,r29
 2435 0016 0FBE      		out __SREG__,__tmp_reg__
 2436 0018 CDBF      		out __SP_L__,r28
 2437 001a DF91      		pop r29
 2438 001c CF91      		pop r28
 2439 001e 0895      		ret
 2440               		.cfi_endproc
 2441               	.LFE30:
 2443               		.section	.text.debug_action,"ax",@progbits
 2444               	.global	debug_action
 2446               	debug_action:
 2447               	.LVL254:
 2448               	.LFB31:
1002:tmk_core/common/action.c **** 
1003:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1004:tmk_core/common/action.c ****  *
1005:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1006:tmk_core/common/action.c ****  */
1007:tmk_core/common/action.c **** void debug_action(action_t action)
1008:tmk_core/common/action.c **** {
 2449               		.loc 1 1008 1 is_stmt 1 view -0
 2450               		.cfi_startproc
 2451               	/* prologue: function */
 2452               	/* frame size = 0 */
 2453               	/* stack size = 0 */
 2454               	.L__stack_usage = 0
1009:tmk_core/common/action.c ****     switch (action.kind.id) {
 2455               		.loc 1 1009 5 view .LVU623
1010:tmk_core/common/action.c ****         case ACT_LMODS:             dprint("ACT_LMODS");             break;
1011:tmk_core/common/action.c ****         case ACT_RMODS:             dprint("ACT_RMODS");             break;
1012:tmk_core/common/action.c ****         case ACT_LMODS_TAP:         dprint("ACT_LMODS_TAP");         break;
1013:tmk_core/common/action.c ****         case ACT_RMODS_TAP:         dprint("ACT_RMODS_TAP");         break;
1014:tmk_core/common/action.c ****         case ACT_USAGE:             dprint("ACT_USAGE");             break;
1015:tmk_core/common/action.c ****         case ACT_MOUSEKEY:          dprint("ACT_MOUSEKEY");          break;
1016:tmk_core/common/action.c ****         case ACT_LAYER:             dprint("ACT_LAYER");             break;
1017:tmk_core/common/action.c ****         case ACT_LAYER_MODS:        dprint("ACT_LAYER_MODS");        break;
1018:tmk_core/common/action.c ****         case ACT_LAYER_TAP:         dprint("ACT_LAYER_TAP");         break;
1019:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:     dprint("ACT_LAYER_TAP_EXT");     break;
1020:tmk_core/common/action.c ****         case ACT_MACRO:             dprint("ACT_MACRO");             break;
1021:tmk_core/common/action.c ****         case ACT_COMMAND:           dprint("ACT_COMMAND");           break;
1022:tmk_core/common/action.c ****         case ACT_FUNCTION:          dprint("ACT_FUNCTION");          break;
1023:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:        dprint("ACT_SWAP_HANDS");        break;
1024:tmk_core/common/action.c ****         default:                    dprint("UNKNOWN");               break;
1025:tmk_core/common/action.c ****     }
1026:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param>>8, action.kind.param&0xff);
 2456               		.loc 1 1026 71 view .LVU624
 2457               	/* epilogue start */
1027:tmk_core/common/action.c **** }
 2458               		.loc 1 1027 1 is_stmt 0 view .LVU625
 2459 0000 0895      		ret
 2460               		.cfi_endproc
 2461               	.LFE31:
 2463               	.global	disable_action_cache
 2464               		.section	.bss.disable_action_cache,"aw",@nobits
 2467               	disable_action_cache:
 2468 0000 00        		.zero	1
 2469               		.comm	tp_buttons,2,1
 2470               		.text
 2471               	.Letext0:
 2472               		.file 4 "/usr/local/Cellar/avr-gcc@8/8.3.0/avr/include/stdint.h"
 2473               		.file 5 "tmk_core/common/keycode.h"
 2474               		.file 6 "tmk_core/common/report.h"
 2475               		.file 7 "tmk_core/common/host.h"
 2476               		.file 8 "tmk_core/common/mousekey.h"
 2477               		.file 9 "tmk_core/common/command.h"
 2478               		.file 10 "tmk_core/common/action_code.h"
 2479               		.file 11 "tmk_core/common/action.h"
 2480               		.file 12 "tmk_core/common/action_layer.h"
 2481               		.file 13 "tmk_core/common/action_util.h"
 2482               		.file 14 "tmk_core/common/avr/xprintf.h"
 2483               		.file 15 "tmk_core/common/debug.h"
 2484               		.file 16 "tmk_core/common/led.h"
 2485               		.file 17 "tmk_core/common/action_macro.h"
 2486               		.file 18 "tmk_core/common/backlight.h"
 2487               		.file 19 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:4      *ABS*:000000000000003f __SREG__
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:13     .text.action_exec:0000000000000000 action_exec
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:94     .text.process_record_quantum:0000000000000000 process_record_quantum
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:116    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:141    .text.register_code:0000000000000000 register_code
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:679    .text.unregister_code:0000000000000000 unregister_code
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:837    .text.tap_code:0000000000000000 tap_code
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:901    .text.register_mods:0000000000000000 register_mods
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:930    .text.unregister_mods:0000000000000000 unregister_mods
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:959    .text.process_action:0000000000000000 process_action
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:2037   .text.process_record:0000000000000000 process_record
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:2148   .text.process_record_nocache:0000000000000000 process_record_nocache
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:2467   .bss.disable_action_cache:0000000000000000 disable_action_cache
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:2176   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:2209   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:2229   .text.clear_keyboard:0000000000000000 clear_keyboard
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:2249   .text.is_tap_action:0000000000000000 is_tap_action
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:2337   .text.is_tap_key:0000000000000000 is_tap_key
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:2360   .text.debug_event:0000000000000000 debug_event
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:2402   .text.debug_record:0000000000000000 debug_record
/var/folders/kv/ylqhzlcd2rs16mxjtd8q7x600000gn/T//ccJrsBfI.s:2446   .text.debug_action:0000000000000000 debug_action
                            *COM*:0000000000000002 tp_buttons

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
host_keyboard_leds
add_key
send_keyboard_report
del_key
add_mods
host_system_send
host_consumer_send
del_mods
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
action_get_macro
action_macro_play
backlight_decrease
backlight_level
backlight_increase
backlight_toggle
backlight_step
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys
clear_mods
__do_clear_bss
